---
layout     : post
title      : "《数据结构与算法:python语言描述》之树与二叉树"
categories : 数据结构与算法
tags       : 数据结构 算法 树 二叉树
excerpt    : "阅读《数据结构与算法:python语言描述》课件中“树与二叉树”部分所写笔记"
---
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#一复杂数据结构">一、复杂数据结构</a>
<ul>
<li><a href="#问题">1. 问题</a></li>
<li><a href="#处理方法可能变得复杂">2. 处理方法可能变得复杂</a></li>
</ul>
</li>
<li><a href="#二树形结构">二、树形结构</a>
<ul>
<li><a href="#特征">1. 特征</a></li>
<li><a href="#树的实例">2. 树的实例</a></li>
<li><a href="#树的表示">3. 树的表示</a></li>
<li><a href="#树的定义">4. 树的定义</a></li>
<li><a href="#相关概念">5. 相关概念</a></li>
</ul>
</li>
<li><a href="#三二叉树">三、二叉树</a>
<ul>
<li><a href="#定义">1. 定义</a></li>
<li><a href="#特点">2. 特点</a></li>
<li><a href="#基本形态">3. 基本形态</a></li>
<li><a href="#概念">4. 概念</a></li>
<li><a href="#性质">5. 性质</a></li>
<li><a href="#操作">6. 操作</a></li>
<li><a href="#实现">7. 实现</a></li>
</ul>
</li>
<li><a href="#四二叉树应用">四、二叉树应用</a>
<ul>
<li><a href="#表达式树">1. 表达式树</a></li>
<li><a href="#x表达式求值">2. X表达式求值</a></li>
<li><a href="#优先队列">3. 优先队列</a></li>
<li><a href="#堆">4. 堆</a></li>
<li><a href="#优先队列应用">5. 优先队列应用</a></li>
</ul>
</li>
<li><a href="#五二叉树的链接实现">五、二叉树的链接实现</a>
<ul>
<li><a href="#结点的类定义">1. 结点的类定义</a></li>
<li><a href="#递归性质">2. 递归性质</a></li>
</ul>
</li>
<li><a href="#六二叉树的遍历">六、二叉树的遍历</a>
<ul>
<li><a href="#遍历">1. 遍历</a></li>
<li><a href="#遍历方式">2. 遍历方式</a></li>
</ul>
</li>
<li><a href="#七二叉树遍历算法">七、二叉树遍历算法</a>
<ul>
<li><a href="#递归形式程序实现">1. 递归形式程序实现</a></li>
<li><a href="#宽度优先程序实现">2. 宽度优先程序实现</a></li>
<li><a href="#非递归定义">3. 非递归定义</a></li>
<li><a href="#递归和非递归遍历">4. 递归和非递归遍历</a></li>
<li><a href="#二叉树数据结构">5. 二叉树数据结构</a></li>
</ul>
</li>
<li><a href="#八哈夫曼树">八、哈夫曼树</a>
<ul>
<li><a href="#定义-1">1. 定义</a></li>
<li><a href="#哈夫曼算法">2. 哈夫曼算法</a></li>
<li><a href="#哈夫曼编码">3. 哈夫曼编码</a></li>
</ul>
</li>
<li><a href="#九树">九、树</a>
<ul>
<li><a href="#树的表示-1">1. 树的表示</a></li>
<li><a href="#树林与二叉树的对应转换">2. 树林与二叉树的对应（转换）</a></li>
<li><a href="#结点链接表示法">3. 结点链接表示法</a></li>
<li><a href="#子表表示法">4. 子表表示法</a></li>
<li><a href="#总结">5. 总结</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="orgc101da4" class="outline-2">
<h2 id="一复杂数据结构"><a id="orgc101da4"></a>一、复杂数据结构</h2>
<div class="outline-text-2" id="text-一复杂数据结构">
<ul class="org-ul">
<li><code>非线性，元素之间的关系不是一对一的</code> ，存在更复杂的关系</li>
<li><code>n 个元素的数据结构，元素间的最远距离不是 n，可能小得多</code></li>
</ul>
</div>

<div id="org509f003" class="outline-3">
<h3 id="问题"><a id="org509f003"></a>1. 问题</h3>
<div class="outline-text-3" id="text-问题">
<ul class="org-ul">
<li>可以表示数据之间更复杂的关系</li>
<li>数据的组织方式有更多选择</li>
<li>可能存在更多不同的实现方法</li>
</ul>
</div>
</div>

<div id="orga48b0b4" class="outline-3">
<h3 id="处理方法可能变得复杂"><a id="orga48b0b4"></a>2. 处理方法可能变得复杂</h3>
<div class="outline-text-3" id="text-处理方法可能变得复杂">
<ul class="org-ul">
<li><code>需要借助一些辅助数据结构，例如栈和队列</code></li>
</ul>
</div>
</div>
</div>

<div id="orgef10e7d" class="outline-2">
<h2 id="二树形结构"><a id="orgef10e7d"></a>二、树形结构</h2>
<div class="outline-text-2" id="text-二树形结构">
<ul class="org-ul">
<li>树形结构也是由结点（树形结构中的逻辑单元，可用于保存数据）和结点的联系构成</li>
</ul>
</div>

<div id="orgf107209" class="outline-3">
<h3 id="特征"><a id="orgf107209"></a>1. 特征</h3>
<div class="outline-text-3" id="text-特征">
<ul class="org-ul">
<li><code>每个节点都只有一个前驱（与线性结构一样）</code></li>
<li><code>一个结点可以有多个后继（不同于线性结构）</code></li>
<li>从一个树形结构的任意两个结点出发，通过后继关系可达的结点集合，相互之间或者互不相交，或者有子集关系</li>
<li>树形结构可以表示许多常见的层次性关系， <code>层次结构</code></li>
</ul>
</div>
</div>

<div id="org0c17aa6" class="outline-3">
<h3 id="树的实例"><a id="org0c17aa6"></a>2. 树的实例</h3>
<div class="outline-text-3" id="text-树的实例">
<ul class="org-ul">
<li>家族关系</li>
<li>机构的结构关系</li>
<li>例如：一个机构的分层结构

<ul class="org-ul">
<li>假设机构A有两个分部 B,C;B 和 C 分别有下级结构 D,E,F 和 G,H;而且 E
有两个小组 I,J</li>
<li><p>
通过结点集合 N 和关系 R，就是一个树形结构：
</p>

<pre class="example">
N={A,B,C,D,E,F,G,H,I,J}
R={&lt;A,B&gt;,&lt;A,C&gt;,&lt;B,D&gt;,&lt;B,E&gt;,&lt;B,F&gt;,&lt;C,G&gt;,&lt;C,H&gt;,&lt;E,I&gt;,&lt;E,J&gt;}
</pre></li>
</ul></li>
</ul>
</div>
</div>

<div id="orgd13d12e" class="outline-3">
<h3 id="树的表示"><a id="orgd13d12e"></a>3. 树的表示</h3>
<div class="outline-text-3" id="text-树的表示">
<ul class="org-ul">
<li>基本图示法，树根总画在最上面</li>
<li>文氏图，也称韦恩图</li>
<li>嵌套括号表示法</li>
</ul>
</div>
</div>

<div id="org7f6d63c" class="outline-3">
<h3 id="树的定义"><a id="org7f6d63c"></a>4. 树的定义</h3>
<div class="outline-text-3" id="text-树的定义">
<ul class="org-ul">
<li>树是具有 <code>递归性质</code> 的结构，所以树的定义也是 <code>递归的</code></li>
<li>一棵树是 n(n&gt;=0) 个结点的有限集 T（可为空），T 非空时满足：

<ul class="org-ul">
<li>有且仅有一个特殊的称为根的结点 r</li>
<li>根结点外的其余结点划分为 m(m&gt;=0) 个互不相交的非空有限集
T1,T2&#x2026;Tm，每个集合各位一颗非空树，称为 r 的子树（subtree）</li>
</ul></li>

<li>要求子树都非空，使子树的个数能有明确定义

<ul class="org-ul">
<li>结点个数为 0 的树称为空树</li>
<li>一棵树可以只有根但没有子树(m=0),这是一颗单结点的树，只包含一个根结点</li>
</ul></li>
</ul>
</div>
</div>

<div id="org01caa66" class="outline-3">
<h3 id="相关概念"><a id="org01caa66"></a>5. 相关概念</h3>
<div class="outline-text-3" id="text-相关概念">
<ul class="org-ul">
<li>根据是否认为子树的排列顺序有意义，可以分为有序树和无序树两种概念</li>
<li>父结点与子结点（ <code>相对定义</code> ）

<ul class="org-ul">
<li>一棵树的根结点称为该树的子树的根结点的父结点</li>
<li>子树的根是树根的子结点</li>
</ul></li>

<li>边 <code>从父结点到子结点的连线（有方向）</code></li>
<li>兄弟结点 父结点相同的结点互为兄弟结点</li>
<li>树叶、分支结点没有子结点的结点称为树叶，树中的其余结点称为分支结点（分支结点可以只有一个分支）</li>
<li>祖先和子孙基于父结点/子结点关系和传递性，可以确定相应的传递关系，称为祖先关系或子孙关系。这两个关系决定一个结点的祖先结点，或子孙结点</li>
<li><code>度数</code>
一个结点的子结点个数称为该结点的度数，显然树叶的度数为0，一棵树的度数就是其里面度数最大的结点的度数</li>
<li><code>路径、路径长度</code>

<ul class="org-ul">
<li>从一个祖先结点到其子孙结点的一系列边称为树中的一条路径，从树的根到树种任一个结点都有路径，且路径唯一</li>
<li>路径中边的条数称为路径长度，认为每个结点到自身有长0的路径</li>
</ul></li>

<li><code>结点的层数</code>

<ul class="org-ul">
<li>树根到结点的路径长度是该结点的层数</li>
<li>结点都有层数，根所在的层为 0</li>
</ul></li>

<li><code>高度（或深度）</code>

<ul class="org-ul">
<li>树的高度或深度是树中结点的最大层数（最长路径的长度）加 1</li>
<li>是树的整体性质，空树高度为 0，只有根结点的树高度为 1</li>
</ul></li>

<li>结点的顺序（仅在考虑有序树时有意义）</li>
<li><code>树林</code> m(m&gt;=0) 棵互不相交的树的集合</li>
<li>一棵非空树是一个二元组 Tree=(r，F)，其中

<ul class="org-ul">
<li>r 是树的根结点</li>
<li>F 是 m（m&gt;=0）棵子树构成的树林</li>
<li>F=(T1,T2&#x2026;T1)。其中 T1 称为根 r 的第 i
棵子树（有序树情况。对于无序树F是一个集合，F={T1,T2&#x2026;T1}）</li>
</ul></li>

<li>注意树与树林的关系

<ul class="org-ul">
<li>树由根域子树树林构成</li>
<li>树林由一集树组成</li>
<li>树和树林可以相互递归定义</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="orgb580b17" class="outline-2">
<h2 id="三二叉树"><a id="orgb580b17"></a>三、二叉树</h2>
<div class="outline-text-2" id="text-三二叉树">
<ul class="org-ul">
<li><code>特点是与每个结点关联的子结点至多有两个</code> （可为 0，1，2）</li>
<li>每个结点的子结点关联有位置关系</li>
</ul>
</div>

<div id="org3f3307a" class="outline-3">
<h3 id="定义"><a id="org3f3307a"></a>1. 定义</h3>
<div class="outline-text-3" id="text-定义">
<ul class="org-ul">
<li>二叉树是结点的有限集合，该集合或为空集，或由一个根元素和两棵不相交的二叉树组成（递归定义）</li>
<li><code>二叉树的两棵子树分别称作它的左子树和右子树</code></li>
</ul>
</div>
</div>

<div id="org0e17fcf" class="outline-3">
<h3 id="特点"><a id="org0e17fcf"></a>2. 特点</h3>
<div class="outline-text-3" id="text-特点">
<ul class="org-ul">
<li><code>一个结点至多有两棵子树</code></li>
<li><code>子树有左右之分</code> （因此二叉树与树有不同结构，不是树的特殊情况）</li>
</ul>
</div>
</div>

<div id="org415e7f0" class="outline-3">
<h3 id="基本形态"><a id="org415e7f0"></a>3. 基本形态</h3>
<div class="outline-text-3" id="text-基本形态">
<ul class="org-ul">
<li>空二叉树、只有根结点、只有左子树、只有右子树、左右子树都不空</li>
<li>由于分左右子树，即使只有一棵子树也要明确说明是左还是右，画二叉树时要明确地把子树画在左边或右边</li>
</ul>
</div>
</div>

<div id="org13426ee" class="outline-3">
<h3 id="概念"><a id="org13426ee"></a>4. 概念</h3>
<div class="outline-text-3" id="text-概念">
<ul class="org-ul">
<li>可沿用树的许多概念</li>
<li><code>满二叉树：树中每个分支结点（非叶结点）都有两棵非空子树</code></li>
<li><code>完全二叉树：除最下两层外，其余结点度数都是2，如果最下一层的结点不满，则所有空位都在右边，左边没有空位</code></li>
</ul>
</div>

<div id="org1a9a7b2" class="outline-4">
<h4 id="a.-扩充二叉树"><a id="org1a9a7b2"></a>a. 扩充二叉树</h4>
<div class="outline-text-4" id="text-a.-扩充二叉树">
<ul class="org-ul">
<li><code>原二叉树的最小结点扩充，使原树中所有结点的度数都变成2</code></li>
<li>扩充二叉树新增结点（称其为外部结点）的个数比原树结点（称其为内部结点）的个数多
1

<ul class="org-ul">
<li>如果原树只有一个结点，结论显然成立</li>
<li>如果原树包含根结点r和左右子树</li>
</ul></li>

<li>扩充二叉树性质（其中n是内部结点的个数）： <code>E=l+2n</code>

<ul class="org-ul">
<li>E
是扩充二叉树的外部路径长度：扩充二叉树里从根到各外部结点的路径长度之和</li>
<li>l 是扩充二叉树的内部路径：扩充二叉树从根到各内部结点的路径长度之和</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="org3d0a55e" class="outline-3">
<h3 id="性质"><a id="org3d0a55e"></a>5. 性质</h3>
<div class="outline-text-3" id="text-性质">
<ul class="org-ul">
<li>非空二叉树第 i 层上至多有 2i 个结点（i&gt;=0）</li>
<li>高度为k的二叉树至多有 2k-1 个结点（k&gt;=0）</li>
<li>对任何非空二叉树 T，若其叶结点个数为 n0，度数为 2 的结点个数为 n2，则
n0=n2+1</li>
<li>n 个结点的完全二叉树的高度 k=[log2(n+1)]</li>
<li>满二叉树里叶结点比分支节点多一个</li>
<li>如果 n 个结点的完全二叉树按层次按从左到右的顺序从 0
开始编号，对任一结点 i(0&lt;=i&lt;=n-1) 都有：

<ul class="org-ul">
<li>序号 0 的结点是根；对于 i&gt;0，其父结点是 <code>(i-1)/2</code></li>
<li>若 <code>2*i+1&lt;=n</code> ，其左子结点序号为 <code>2*i+1</code> ；否则它无左子结点</li>
<li>做 <code>2*2+1&lt;=n</code> ，其右子结点序号为 <code>2*i+2</code> ；否则它无右子结点</li>
</ul></li>

<li>完全二叉树的一个重要性质：

<ul class="org-ul">
<li>不需要另外保存其他信息，直接根据元素的下标就可以找到一个结点的子结点或者父结点（并确定二叉树结构）</li>
<li>使其可以方便地存入一系列连续位置</li>
<li>一般二叉树不能方便地映射到线性结构，完全二叉树到线性结构有定义非常自然的双向映射，可以方便地从其线性结构恢复完全二叉树</li>
</ul></li>

<li>对于n个结点的二叉树：

<ul class="org-ul">
<li>如果足够丰满整齐， <code>树中最长路径的长度将为 O(logn)</code></li>
<li>如果比较畸形， <code>最长路径的长度可能为 O(n)</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="orgf8272d4" class="outline-3">
<h3 id="操作"><a id="orgf8272d4"></a>6. 操作</h3>
<div class="outline-text-3" id="text-操作">
<ul class="org-ul">
<li>创建二叉树</li>
<li>一棵二叉树或为空，或是两棵已有二叉树和要存在树根结点的一项数据，构造起的根结点代表构造出的二叉树： <code>BiTree(dat,left,right)</code></li>
<li>判断树空： <code>is_empty(bitree)</code></li>
<li>访问操作：

<ul class="org-ul">
<li>访问二叉树的根结点数据元素： <code>data()</code></li>
<li>取得一棵二叉树的左右子树： <code>right()</code> ， <code>left()</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="org3bcf896" class="outline-3">
<h3 id="实现"><a id="org3bcf896"></a>7. 实现</h3>
<div class="outline-text-3" id="text-实现">
<ul class="org-ul">
<li>考虑 list 实现，也可用于实现一般的树</li>
</ul>
</div>

<div id="org3ddee21" class="outline-4">
<h4 id="a.-采用如下设计"><a id="org3ddee21"></a>a. 采用如下设计</h4>
<div class="outline-text-4" id="text-a.-采用如下设计">
<ul class="org-ul">
<li>空树用 <code>[]</code> 表示</li>
<li>非空二叉树用包含三个元素的表 <code>[d,l,r]</code> 表示。其中 <code>d</code>
为存在根结点的元素， <code>l</code> 和 <code>r</code> 是两棵子树</li>
<li>显然，这种设计是一种递归结构，也就是前面的嵌套括号表示</li>
</ul>
</div>
</div>

<div id="org87ea319" class="outline-4">
<h4 id="b.-程序实现"><a id="org87ea319"></a>b. 程序实现</h4>
<div class="outline-text-4" id="text-b.-程序实现">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">BiTree</span><span style="color: #2aa198;">(</span>data,left,right<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span>data,left,right<span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">is_empty</span><span style="color: #2aa198;">(</span>bitree<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> bitree == <span style="color: #2aa198;">[]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">root</span><span style="color: #2aa198;">(</span>bitree<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> bitree<span style="color: #2aa198;">[</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">letfch</span><span style="color: #2aa198;">(</span>bitree<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> bitree<span style="color: #2aa198;">[</span><span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">rightch</span><span style="color: #2aa198;">(</span>bitree<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> bitree<span style="color: #2aa198;">[</span><span style="color: #6c71c4;">2</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_root</span><span style="color: #2aa198;">(</span>bitree, data<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">bitree</span><span style="color: #2aa198;">[</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span> = data

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_left</span><span style="color: #2aa198;">(</span>bitree, left<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">bitree</span><span style="color: #2aa198;">[</span><span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span> = left

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_right</span><span style="color: #2aa198;">(</span>bitree, right<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">bitree</span><span style="color: #2aa198;">[</span><span style="color: #6c71c4;">2</span><span style="color: #2aa198;">]</span> = right
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="org8223675" class="outline-2">
<h2 id="四二叉树应用"><a id="org8223675"></a>四、二叉树应用</h2>
<div class="outline-text-2" id="text-四二叉树应用">
</div>

<div id="org2059745" class="outline-3">
<h3 id="表达式树"><a id="org2059745"></a>1. 表达式树</h3>
<div class="outline-text-3" id="text-表达式树">
<ul class="org-ul">
<li>基本运算对象作为叶结点的数据</li>
<li><code>运算符作为分支结点的数据，其两棵树是它的运算对象</code> ，可以是基本运算对象，也可以是作为运算对象的两个表达式</li>
<li>例如表达式 <code>3 * (2 + 5)</code>:
<code>['*', [3, [], []], ['+', [2, [], []], [5, [], []]]]</code>
简化为： <code>['*', 3, ['+', 2, 5]]</code></li>
<li>上述简化的表达式由两种结构组成：

<ul class="org-ul">
<li>如果是表，就是运算符作用于运算对象的复合表达式</li>
<li>否则就是基本表达式，即数或者变量</li>
<li>上述两条用于解析表达式的结构，实现对表达式的处理</li>
<li>算术表达式是特殊情况，其基本表达式都是数</li>
</ul></li>
</ul>
</div>

<div id="orgd6cfc7a" class="outline-4">
<h4 id="a.-程序实现"><a id="orgd6cfc7a"></a>a. 程序实现</h4>
<div class="outline-text-4" id="text-a.-程序实现">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">make_sum</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'+'</span>, a, b<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">make_prod</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'*'</span>, a, b<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">make_diff</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'-'</span>, a, b<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">make_div</span><span style="color: #2aa198;">(</span>a, b<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'/'</span>, a, b<span style="color: #2aa198;">]</span>
</pre>
</div>

<ul class="org-ul">
<li><code>isinstance(a, list)</code> 判断是否为基本表达式</li>
<li><code>isinstance(x, Number)</code> 判断是否为数，需要导入 Number</li>
</ul>
</div>
</div>
</div>

<div id="orgd49f2bd" class="outline-3">
<h3 id="x表达式求值"><a id="orgd49f2bd"></a>2. X表达式求值</h3>
<div class="outline-text-3" id="text-x表达式求值">
<ul class="org-ul">
<li>对表达式里的数和变量，其值就是它们自身</li>
<li>其他表达式，要根据运算符的情况处理</li>
<li>如一个运算符的两个运算对象都是数，那就可以求出一个数值</li>
<li>特殊情况，如加数为0，乘数是0或1，可部分求值化简</li>
</ul>
</div>
</div>

<div id="org3e9c394" class="outline-3">
<h3 id="优先队列"><a id="org3e9c394"></a>3. 优先队列</h3>
<div class="outline-text-3" id="text-优先队列">
<ul class="org-ul">
<li>是一种常用的缓存结构，与栈和队列类似</li>
<li><code>特点是存入的每项数据附有一个优先级</code></li>
<li><code>保证任何时候访问或弹出的总是当时优先级最高的元素</code></li>
</ul>
</div>

<div id="org35eea0c" class="outline-4">
<h4 id="a.-实现的效率问题"><a id="org35eea0c"></a>a. 实现的效率问题</h4>
<div class="outline-text-4" id="text-a.-实现的效率问题">
<ul class="org-ul">
<li>若存在多个最优先元素

<ul class="org-ul">
<li>若要求这些元素的先进先出，则只能做出效率较低的实现</li>
<li>若只要求保证是最优先元素中的一个，则存在效率更高的实现</li>
</ul></li>
</ul>
</div>
</div>

<div id="orgab0013c" class="outline-4">
<h4 id="b.-实际应用"><a id="orgab0013c"></a>b. 实际应用</h4>
<div class="outline-text-4" id="text-b.-实际应用">
<ul class="org-ul">
<li>各项工作的计划开始时间</li>
<li>一个大项目中各种工作任务的急迫程度</li>
<li>银行客户的诚信评估，用于决定优先贷款，等等</li>
</ul>
</div>
</div>

<div id="org6bc2a96" class="outline-4">
<h4 id="c.-操作"><a id="org6bc2a96"></a>c. 操作</h4>
<div class="outline-text-4" id="text-c.-操作">
<ul class="org-ul">
<li>创建，判断空</li>
<li>插入元素，访问和删除优先队列里的元素</li>
</ul>
</div>
</div>

<div id="orgac216ab" class="outline-4">
<h4 id="d.-基于线性表技术"><a id="orgac216ab"></a>d. 基于线性表技术</h4>
<div class="outline-text-4" id="text-d.-基于线性表技术">
<ul class="org-ul">
<li>存在两种实现方案：

<ul class="org-ul">
<li>存入时保证元素按优先顺序排列</li>
<li>元素直接存到表的尾端，取用时检索最优先元素</li>
</ul></li>

<li>分析后选择第一种

<ul class="org-ul">
<li>加入新元素时，确定正确插入位置</li>
<li>为保证 <code>O(1)</code> 的弹出操作， <code>最优先元素应该出现在尾端</code></li>
<li>注意： <code>插入元素只能用 insert（或其他类似操作），不能用元素位移，因为 list 超下标范围的赋值会出错</code></li>
</ul></li>
</ul>
</div>

<div id="orgc6ad311" class="outline-5">
<h5 id="程序实现"><a id="orgc6ad311"></a>程序实现</h5>
<div class="outline-text-5" id="text-程序实现">
<ul class="org-ul">
<li><p>
先定义一个类：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PriQue</span><span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">object</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, lst=<span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.elems = <span style="color: #839496; font-weight: bold;">sorted</span><span style="color: #2aa198;">(</span>lst<span style="color: #2aa198;">)</span>
</pre>
</div></li>

<li><p>
插入元素操作：假设元素可用&lt;=比较，把较小看作优先
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">i</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">)</span> - <span style="color: #6c71c4;">1</span>
    <span style="color: #859900; font-weight: bold;">while</span> i &gt;= <span style="color: #6c71c4;">0</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> &lt;= e:
            <span style="color: #268bd2;">i</span> -= <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #859900; font-weight: bold;">break</span>
    <span style="color: #859900; font-weight: bold;">self</span>.elems.insert<span style="color: #2aa198;">(</span>i+<span style="color: #6c71c4;">1</span>, e<span style="color: #2aa198;">)</span>
</pre>
</div></li>

<li><p>
其他操作：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">is_empty</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems == <span style="color: #2aa198;">[]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">peek</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.is_empty<span style="color: #2aa198;">()</span>:
        <span style="color: #859900; font-weight: bold;">raise</span> PriQueueError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"in top"</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">[</span><span style="color: #839496; font-weight: bold;">len</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #b58900;">)</span>-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.is_empty<span style="color: #2aa198;">()</span>:
        <span style="color: #859900; font-weight: bold;">raise</span> PriQueueError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"in top"</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems.pop<span style="color: #2aa198;">()</span>

<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PriQueueError</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">ValueError</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">pass</span>
</pre>
</div></li>

<li>操作效率分析

<ul class="org-ul">
<li>插入是 <code>O(n)=，其他都是 =O(1)</code></li>
<li>如果采用第二种，插入式 <code>O(1)=，检查和弹出都是 =O(n)</code></li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="orgab31235" class="outline-4">
<h4 id="e.-树形结构实现"><a id="orgab31235"></a>e. 树形结构实现</h4>
<div class="outline-text-4" id="text-e.-树形结构实现">
<ul class="org-ul">
<li>由于使用线性表时元素按线性顺序排列元素，因此不可避免插入元素需要O(n)</li>
<li>基于树形结构，插入时就不必重复检索同一优先级其他元素</li>
<li>树形结构实现需要解决：在反复插入和删除元素中，如何始终保证结构的有效性</li>
<li>采用树形结构实现优先队列的一种有效技术称为堆</li>
</ul>
</div>
</div>
</div>

<div id="orgacea54c" class="outline-3">
<h3 id="堆"><a id="orgacea54c"></a>4. 堆</h3>
<div class="outline-text-3" id="text-堆">
<ul class="org-ul">
<li><code>结构上是一棵在结点里存储数据的完全二叉树</code></li>
<li><code>元素按数据优先关系排序，这种堆序保证任一结的数据不大于其子结点的数据</code></li>
<li><code>注意：堆序要求按结点子孙序，数据从小到大递增</code></li>
</ul>
</div>

<div id="org953e6ca" class="outline-4">
<h4 id="a.-堆特点"><a id="org953e6ca"></a>a. 堆特点</h4>
<div class="outline-text-4" id="text-a.-堆特点">
<ul class="org-ul">
<li><code>堆中最优先元素位于堆顶，O(1) 操作获取</code></li>
<li><code>位于树中不同路径上的元素，这里不关心其顺序关系</code></li>
</ul>
</div>
</div>

<div id="org0db652f" class="outline-4">
<h4 id="b.-堆的分类"><a id="org0db652f"></a>b. 堆的分类</h4>
<div class="outline-text-4" id="text-b.-堆的分类">
<ul class="org-ul">
<li>小元素在上的称为 <code>小顶堆</code></li>
<li>大元素在上的称为 <code>大顶堆</code></li>
</ul>
</div>
</div>

<div id="orge9fda96" class="outline-4">
<h4 id="c.-实现特点"><a id="orge9fda96"></a>c. 实现特点</h4>
<div class="outline-text-4" id="text-c.-实现特点">
<ul class="org-ul">
<li>一棵完全二叉树可以很自然而且信息完全地存入一个连续的线性结构，因此堆也可以，仅使用下标就能方便访问树中一个结点的父结点或子结点</li>
<li>去掉一个堆的最后元素，剩下的仍是堆</li>
<li>去掉堆顶，其余元素形成两个堆</li>
<li>上面两个堆加一个元素作为根，得到一棵完全二叉树但未必是堆</li>
<li>堆最后加上一个元素，整个结构是一棵完全二叉树但未必是堆</li>
</ul>
</div>
</div>

<div id="org63dab43" class="outline-4">
<h4 id="d.-实现问题"><a id="org63dab43"></a>d. 实现问题</h4>
<div class="outline-text-4" id="text-d.-实现问题">
<ul class="org-ul">
<li>加入一个元素，怎样将加入后得到的完全二叉树转变为堆</li>
<li>弹出元素后，任何将剩下的元素重新做成堆</li>
</ul>
</div>
</div>

<div id="org90e97d8" class="outline-4">
<h4 id="e.-向上筛选和向下筛选"><a id="org90e97d8"></a>e. 向上筛选和向下筛选</h4>
<div class="outline-text-4" id="text-e.-向上筛选和向下筛选">
<ul class="org-ul">
<li>向上筛选：在堆H的最后加入一个元素e后，通过一次向上筛选，使整个完全二叉树重新恢复为一个堆

<ul class="org-ul">
<li>不断用e与其父结点的数据比较，如果e较小就交换两个元素位置。直至 e
的父结点的数据小于等于 e 时停止</li>
</ul></li>

<li>向下筛选：设两个堆 B,C 加根元素 e
构成一棵完全二叉树，通过一次向下筛选把它们做成堆

<ul class="org-ul">
<li>用 e 与 B、C 的根比较，最小者作为整个堆的顶。若 e
不是最小，最小的必为 B( 或 C）的顶元素。下面考虑把 e 放入去掉堆顶的
B(或 C）：

<ul class="org-ul">
<li>某次比较中 e 最小，以它为顶的局部树成堆了，整个结构也成堆</li>
<li>e 落到底，这时它自身就是一个堆，整个结构也成堆</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div id="org8a44955" class="outline-4">
<h4 id="f.-具体实现"><a id="org8a44955"></a>f. 具体实现</h4>
<div class="outline-text-4" id="text-f.-具体实现">
<ul class="org-ul">
<li>加入元素：从堆的最后加入元素，做一次向上筛选</li>
<li>弹出元素：弹出堆顶元素后，从堆最后取一个元素放在堆顶，做一次向下筛选</li>
<li><p>
优先队列的堆实现程序
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PrioQueue</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, elist = <span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.elems = elist
        <span style="color: #859900; font-weight: bold;">if</span> elist != <span style="color: #2aa198;">[]</span>:
            <span style="color: #859900; font-weight: bold;">self</span>.buildheap<span style="color: #2aa198;">()</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">is_empty</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">)</span> == <span style="color: #6c71c4;">0</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">peek</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.is_empty<span style="color: #2aa198;">()</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> PrioQueueError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"in top"</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">[</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">enqueue</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.elems.append<span style="color: #2aa198;">(</span><span style="color: #268bd2; font-weight: bold;">None</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">self</span>.siftup<span style="color: #2aa198;">(</span>e, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #b58900;">)</span>-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">siftup</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e, last<span style="color: #2aa198;">)</span>:
        <span style="color: #268bd2;">elems</span>, <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = <span style="color: #859900; font-weight: bold;">self</span>.elems, last, <span style="color: #2aa198;">(</span>last-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>//<span style="color: #6c71c4;">2</span>
        <span style="color: #859900; font-weight: bold;">while</span> i &gt; <span style="color: #6c71c4;">0</span> <span style="color: #859900; font-weight: bold;">and</span> e &lt; elems<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>:
            <span style="color: #268bd2;">elems</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = elems<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
            <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = j, <span style="color: #2aa198;">(</span>j-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>//<span style="color: #6c71c4;">2</span>
        <span style="color: #268bd2;">elems</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = e

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">dequeue</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.is_empty<span style="color: #2aa198;">()</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> PrioQueueError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"in top"</span><span style="color: #2aa198;">)</span>
        <span style="color: #268bd2;">elems</span> = <span style="color: #859900; font-weight: bold;">self</span>.elems
        <span style="color: #268bd2;">e0</span> = elems<span style="color: #2aa198;">[</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span>; <span style="color: #268bd2;">e</span> = elems.pop<span style="color: #2aa198;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>elems<span style="color: #2aa198;">)</span> &gt; <span style="color: #6c71c4;">0</span>:
            <span style="color: #859900; font-weight: bold;">self</span>.siftdown<span style="color: #2aa198;">(</span>e, <span style="color: #6c71c4;">0</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #b58900;">(</span>elems<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> e0

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">siftdown</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e, begin, end<span style="color: #2aa198;">)</span>:
        <span style="color: #268bd2;">elems</span>, <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = <span style="color: #859900; font-weight: bold;">self</span>.elems, begin, begin*<span style="color: #6c71c4;">2</span>+<span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">while</span> j &lt; end:
            <span style="color: #859900; font-weight: bold;">if</span> j+<span style="color: #6c71c4;">1</span> &lt; end <span style="color: #859900; font-weight: bold;">and</span> elems<span style="color: #2aa198;">[</span>j+<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span> &lt; elems<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>:
            <span style="color: #586e75;"># </span><span style="color: #586e75;">elems[j]&#20026;&#24038;&#23376;&#32467;&#28857;&#65292;elems[j+1]&#20026;&#21491;&#23376;&#32467;&#28857;</span>
                <span style="color: #268bd2;">j</span> += <span style="color: #6c71c4;">1</span>
            <span style="color: #859900; font-weight: bold;">if</span> e &lt; elems<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>:
            <span style="color: #586e75;"># </span><span style="color: #586e75;">&#33509;e&#26368;&#23567;&#21017;&#36339;&#20986;&#24490;&#29615;&#65292;&#25226;e&#20316;&#20026;&#29238;&#32467;&#28857;&#65292;</span>
                <span style="color: #859900; font-weight: bold;">break</span>
            <span style="color: #268bd2;">elems</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = elems<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
            <span style="color: #586e75;"># </span><span style="color: #586e75;">&#33509;e&#19981;&#26159;&#26368;&#23567;&#65292;&#25226;&#24038;&#21491;&#23376;&#32467;&#28857;&#20013;&#26356;&#23567;&#30340;&#32467;&#28857;       elems[j]&#20316;&#20026;&#29238;&#32467;&#28857;&#65292;&#32487;&#32493;&#29992;&#35813;&#32467;&#28857;&#30340;&#24038;&#21491;&#23376;&#32467;&#28857;&#19982;e&#27604;&#36739;</span>
            <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = j, <span style="color: #6c71c4;">2</span>*j+<span style="color: #6c71c4;">1</span>
        <span style="color: #268bd2;">elems</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = e
</pre>
</div></li>
</ul>
</div>
</div>

<div id="org5df664c" class="outline-4">
<h4 id="g.-堆排序"><a id="org5df664c"></a>g. 堆排序</h4>
<div class="outline-text-4" id="text-g.-堆排序">
</div>
</div>
</div>

<div id="orgc00aa8e" class="outline-3">
<h3 id="优先队列应用"><a id="orgc00aa8e"></a>5. 优先队列应用</h3>
<div class="outline-text-3" id="text-优先队列应用">
</div>

<div id="org7cc081d" class="outline-4">
<h4 id="a.-离散事件模拟"><a id="org7cc081d"></a>a. 离散事件模拟</h4>
<div class="outline-text-4" id="text-a.-离散事件模拟">
<ul class="org-ul">
<li>系统运行中可能发生事件</li>
<li>一个事件在某个时刻发生，有可能导致其他事件在未来发生</li>
</ul>
</div>
</div>

<div id="org1f8ce5c" class="outline-4">
<h4 id="b.-x海关检查站"><a id="org1f8ce5c"></a>b. X海关检查站</h4>
<div class="outline-text-4" id="text-b.-x海关检查站">
</div>
</div>
</div>
</div>

<div id="orgd5bda4a" class="outline-2">
<h2 id="五二叉树的链接实现"><a id="orgd5bda4a"></a>五、二叉树的链接实现</h2>
<div class="outline-text-2" id="text-五二叉树的链接实现">
<ul class="org-ul">
<li>考虑二叉树结构本身在 python 里的实现

<ul class="org-ul">
<li>定义一个二叉树的结点类和一个二叉树类</li>
<li>一个结点通过链接引用到其子结点， <code>没有子结点用 None 值</code></li>
</ul></li>
</ul>
</div>

<div id="org79d5b17" class="outline-3">
<h3 id="结点的类定义"><a id="org79d5b17"></a>1. 结点的类定义</h3>
<div class="outline-text-3" id="text-结点的类定义">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">BitNode</span><span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">object</span><span style="color: #2aa198;">)</span>:

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, dat, left, right<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.data = dat
        <span style="color: #859900; font-weight: bold;">self</span>.left = left
        <span style="color: #859900; font-weight: bold;">self</span>.right = right
</pre>
</div>

<ul class="org-ul">
<li>构造一颗包含三个结点的二叉树，变量t指向树根结点
<code>t = BitNode(1, BitNode(2, None, None), BitNode(3, None, None))</code></li>
</ul>
</div>
</div>

<div id="org05c8790" class="outline-3">
<h3 id="递归性质"><a id="org05c8790"></a>2. 递归性质</h3>
<div class="outline-text-3" id="text-递归性质">
<p>
基于 BitNode 对象构造的二叉树具有递归结构，递归处理非常方便：
</p>

<ol class="org-ol">
<li><p>
统计结点个数：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">count_BitNode</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">0</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">1</span> + count_BitNode<span style="color: #2aa198;">(</span>t.left<span style="color: #2aa198;">)</span> + count_BitNode<span style="color: #2aa198;">(</span>t.right<span style="color: #2aa198;">)</span>
</pre>
</div></li>

<li><p>
对结点中保存的数据进行求和：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">sum_BitNode</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">0</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #859900; font-weight: bold;">return</span> t.data + sum_BitNode<span style="color: #2aa198;">(</span>t.left<span style="color: #2aa198;">)</span> + sum_BitNode<span style="color: #2aa198;">(</span>t.right<span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
递归处理二叉树具有统一的模式：如何处理空树情况，如何分别处理二叉树的左右子树和根，并基于这些得到整个树的处理结果
</p></li>
</ol>
</div>
</div>
</div>

<div id="orgb8d903f" class="outline-2">
<h2 id="六二叉树的遍历"><a id="orgb8d903f"></a>六、二叉树的遍历</h2>
<div class="outline-text-2" id="text-六二叉树的遍历">
<ul class="org-ul">
<li>二叉树唯一标识：根结点

<ul class="org-ul">
<li>从根出发可以找到树里所有信息</li>
<li>因此，常用根结点代表一棵二叉树，其左右子树由它们的根结点代表</li>
</ul></li>
</ul>
</div>

<div id="org52e2f27" class="outline-3">
<h3 id="遍历"><a id="org52e2f27"></a>1. 遍历</h3>
<div class="outline-text-3" id="text-遍历">
<ul class="org-ul">
<li>任何存储数据的汇集结构，都有遍历元素的问题

<ul class="org-ul">
<li>遍历二叉树，就是按某种系统方式访问二叉树里的每个结点一次</li>
<li>可基于二叉树的基本操作实现，遍历中可能操作结点里的数据</li>
<li>很多复杂的二叉树操作需要基于遍历实现，例如找父结点</li>
</ul></li>
</ul>
</div>
</div>

<div id="org2042e34" class="outline-3">
<h3 id="遍历方式"><a id="org2042e34"></a>2. 遍历方式</h3>
<div class="outline-text-3" id="text-遍历方式">
<ul class="org-ul">
<li>两种基本方式：

<ul class="org-ul">
<li><code>深度优先遍历，尽可能沿一条路径向前，必要时回溯</code></li>
<li><code>宽度优先遍历，在所有路径上齐头并进</code></li>
</ul></li>
</ul>
</div>

<div id="orgac72390" class="outline-4">
<h4 id="a.-深度优先遍历处理顺序分类"><a id="orgac72390"></a>a. 深度优先遍历处理顺序分类</h4>
<div class="outline-text-4" id="text-a.-深度优先遍历处理顺序分类">
<ul class="org-ul">
<li>深度优先遍历要做三件事：遍历左子树，遍历右子树，访问根结点（操作其中数据）。下面分别用
L、R、D 表示</li>
<li>根据三项工作的不同排列方式，有三种常见遍历（假设总先处理左子树，否则就是6种）：

<ul class="org-ul">
<li>先根序遍历（DLR）</li>
<li>中根序遍历（LDR），也称对称序</li>
<li>后根序遍历（LRD）</li>
</ul></li>

<li>由于子树也是二叉树，将各种遍历方式继续用到子树遍历中，就形成了遍历二叉树的统一方法：

<ul class="org-ul">
<li>遍历中遇到子树为空就结束对它的处理，转去继续做下一步工作</li>
<li>如先根序遇到左子树空就去遍历右子树</li>
</ul></li>

<li>如果树种数据（或标识）唯一，通过它可以反射到遍历中经过的结点，这时考虑遍历序列就有意义

<ul class="org-ul">
<li>先根序遍历得到的结点序列称为先根序列</li>
<li>后根序遍历得到的称为后根序列</li>
<li>对称序遍历得到的称为对称（中根）序列</li>
</ul></li>

<li>显然给定一棵二叉树，可以唯一确定其先根序列、后跟序列和对称序列</li>
<li>但给定二叉树的任一种遍历序列，无法唯一确定相应的二叉树，如果知道对称序列和另一遍历序列，则可以。如果知道先根序列和后根序列，是否可以确定？</li>
</ul>
</div>
</div>

<div id="orged62ce1" class="outline-4">
<h4 id="b.-宽度优先遍历"><a id="orged62ce1"></a>b. 宽度优先遍历</h4>
<div class="outline-text-4" id="text-b.-宽度优先遍历">
<ul class="org-ul">
<li>逐层访问二叉树各结点，不能写成一个递归过程</li>
<li>做法：

<ul class="org-ul">
<li>从根开始逐层访问</li>
<li>每层都从左到右逐个访问</li>
<li>实现算法需要用一个队列缓存</li>
</ul></li>

<li>宽度优先遍历又称为按层次顺序遍历，产生的结点序列称为二叉树的层次序列</li>
</ul>
</div>
</div>
</div>
</div>

<div id="org508ed4a" class="outline-2">
<h2 id="七二叉树遍历算法"><a id="org508ed4a"></a>七、二叉树遍历算法</h2>
<div class="outline-text-2" id="text-七二叉树遍历算法">
</div>

<div id="orgf4d7f6f" class="outline-3">
<h3 id="递归形式程序实现"><a id="orgf4d7f6f"></a>1. 递归形式程序实现</h3>
<div class="outline-text-3" id="text-递归形式程序实现">
<ul class="org-ul">
<li><p>
先根序：
</p>

<pre class="example">
def preorder(t, proc):
    if t is None:
        return
    proc(t.data)
    preorder(t.lleft, proc)
    preorder(t.right, proc)
</pre></li>

<li><p>
实例：用括号的前缀形式输出二叉树，空子树输出符号 <code>^</code>
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">print_BitNode</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
        <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"^"</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"("</span> + <span style="color: #839496; font-weight: bold;">str</span><span style="color: #b58900;">(</span>t.data<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
    print_BitNode<span style="color: #2aa198;">(</span>t.left<span style="color: #2aa198;">)</span>
    print_BitNode<span style="color: #2aa198;">(</span>t.right<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">")"</span><span style="color: #2aa198;">)</span>
</pre>
</div>

<p>
例如 <code>t = BitNode(1, BitNode(2, None, None), BitNode(3, None, None))</code>
将会输出 <code>(1(2^^)(3^^))</code>
</p></li>
</ul>
</div>
</div>

<div id="org015e80f" class="outline-3">
<h3 id="宽度优先程序实现"><a id="org015e80f"></a>2. 宽度优先程序实现</h3>
<div class="outline-text-3" id="text-宽度优先程序实现">
<ul class="org-ul">
<li><p>
采用宽度优先遍历需要用到一个队列：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">levelorder</span><span style="color: #2aa198;">(</span>t, proc<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">qu</span> = SQueue<span style="color: #2aa198;">()</span>
    qu.enqueue<span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #859900; font-weight: bold;">not</span> qu.is_empty<span style="color: #2aa198;">()</span>:
        <span style="color: #268bd2;">n</span> = qu.dequeue<span style="color: #2aa198;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> n <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            <span style="color: #859900; font-weight: bold;">continue</span>
        proc<span style="color: #2aa198;">(</span>n.data<span style="color: #2aa198;">)</span>
        qu.enqueue<span style="color: #2aa198;">(</span>n.left<span style="color: #2aa198;">)</span>
        qu.enqueue<span style="color: #2aa198;">(</span>n.right<span style="color: #2aa198;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="orga71a46f" class="outline-3">
<h3 id="非递归定义"><a id="orga71a46f"></a>3. 非递归定义</h3>
<div class="outline-text-3" id="text-非递归定义">
</div>

<div id="org08e88af" class="outline-4">
<h4 id="a.-先根序"><a id="org08e88af"></a>a. 先根序</h4>
<div class="outline-text-4" id="text-a.-先根序">
<ul class="org-ul">
<li>先根序的 <code>非递归遍历</code> ， <code>需要用一个栈保存树尚未访问过的部分</code></li>
<li>基本想法：

<ul class="org-ul">
<li>先根序，访问遇到的结点并沿左枝下行，尚未访问的右分支需要记录，将其入栈</li>
<li>与空树时回溯，取出栈中保存的右分支，像一棵树一样遍历它</li>
</ul></li>

<li><p>
算法细节：
</p>

<ul class="org-ul">
<li>循环条件：当前树非空（这棵树需要遍历）或栈不空（还存在整棵树的未遍历部分），这时应该继续循环</li>
<li>在向下检查左分支时把经过结点的右分支入栈（也要用一个循环）</li>
<li>弹出栈中元素（一个右子树）回溯，要做的也是遍历一颗二叉树</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">preporder_nonrec</span><span style="color: #2aa198;">(</span>t, proc<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">s</span> = SStack<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span> <span style="color: #859900; font-weight: bold;">or</span> <span style="color: #859900; font-weight: bold;">not</span> s.is_empty<span style="color: #2aa198;">()</span>:
        <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            proc<span style="color: #2aa198;">(</span>t.data<span style="color: #2aa198;">)</span>
            <span style="color: #268bd2;">t</span> = t.left
            s.push<span style="color: #2aa198;">(</span>t.right<span style="color: #2aa198;">)</span>
</pre>
</div></li>

<li>非递归算法的一个意义是把算法过程完整地暴露出来，便于分析。现在考虑其复杂性：

<ul class="org-ul">
<li>时间复杂性：每个结点访问一次，一部分子树压入弹出栈一次，整个遍历是
O(n) 时间</li>
<li>空间复杂性：关键因素是遍历中栈曾经达到的最大深度，栈的深度由二叉树高度决定，最坏情况的空间复杂性是
O(n)，平均复杂性是
O(logn)，如果只将非空右子树进栈，有可能减少空间开销</li>
</ul></li>
</ul>
</div>

<div id="org39e5341" class="outline-5">
<h5 id="迭代器程序实现"><a id="org39e5341"></a>迭代器程序实现</h5>
<div class="outline-text-5" id="text-迭代器程序实现">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">preorder_iter</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">s</span> = SStack<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span> <span style="color: #859900; font-weight: bold;">or</span> <span style="color: #859900; font-weight: bold;">not</span> s.is_empty:
        <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            <span style="color: #859900; font-weight: bold;">yield</span> t.data
            <span style="color: #268bd2;">t</span> = t.left
            s.push<span style="color: #2aa198;">(</span>t.right<span style="color: #2aa198;">)</span>
        <span style="color: #268bd2;">t</span> = s.pop<span style="color: #2aa198;">()</span>
</pre>
</div>
</div>
</div>
</div>

<div id="orgadb1a6c" class="outline-4">
<h4 id="b.-后根序"><a id="orgadb1a6c"></a>b. 后根序</h4>
<div class="outline-text-4" id="text-b.-后根序">
<ul class="org-ul">
<li>遍历循环中 <code>维持一种不变关系</code> ：

<ul class="org-ul">
<li><code>栈中结点是对二叉树的划分，左边是已遍历过的部分，右边是尚未遍历的部分</code></li>
<li><code>栈中每个结点的父结点就是位于它下面那个结点，当前结点的父结点是栈顶</code></li>
<li>根据本结点是父结点的左子结点或右子结点，可以决定下一步怎么做</li>
<li>在需要从当前结点回溯之前访问这个结点</li>
</ul></li>

<li><p>
程序实现
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">posorder_nonrec</span><span style="color: #2aa198;">(</span>t, proc<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">s</span> = SStack<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span> <span style="color: #859900; font-weight: bold;">or</span> <span style="color: #859900; font-weight: bold;">not</span> s.is_empty<span style="color: #2aa198;">()</span>:
        <span style="color: #859900; font-weight: bold;">while</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            s.push<span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>
            <span style="color: #268bd2;">t</span> = t.left <span style="color: #859900; font-weight: bold;">if</span> t.left <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span> <span style="color: #859900; font-weight: bold;">else</span> t.right
        <span style="color: #268bd2;">t</span> = s.pop<span style="color: #2aa198;">()</span>
        proc<span style="color: #2aa198;">(</span>t.data<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> t <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #268bd2; font-weight: bold;">None</span> <span style="color: #859900; font-weight: bold;">and</span> s.top<span style="color: #2aa198;">()</span>.left == t:
            <span style="color: #268bd2;">t</span> = s.top<span style="color: #2aa198;">()</span>.right
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #268bd2;">t</span> = <span style="color: #268bd2; font-weight: bold;">None</span>
        <span style="color: #586e75;"># </span><span style="color: #586e75;">&#27809;&#26377;&#24038;&#23376;&#26641;&#25110;&#24038;&#23376;&#26641;&#36941;&#21382;&#23436;&#27605;&#65292;&#24378;&#36843;&#36864;&#26632;&#12290;&#32780;&#19981;&#26159;&#27809;&#26377;&#21491;&#23376;&#26641;&#25110;&#21491;&#23376;&#26641;&#36941;&#21382;&#23436;</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="org8bd529e" class="outline-3">
<h3 id="递归和非递归遍历"><a id="org8bd529e"></a>4. 递归和非递归遍历</h3>
<div class="outline-text-3" id="text-递归和非递归遍历">
<ul class="org-ul">
<li>对递归遍历算法，无论用哪种顺序，对深度为n的畸形树，栈深度都会达到 n 或
n-1</li>
<li>非递归遍历算法的情况可能不同

<ul class="org-ul">
<li>后根序遍历必须把未遍历的整条路径存入栈，对深度n的树，栈深度都会达到n</li>
<li>对先根序遍历，如果只入栈非空右子树，遍历单枝树（只有左子树）时栈深度都不会大于
1，最坏情况大约 n/2</li>
<li>中根序与先根序类似</li>
</ul></li>
</ul>
</div>
</div>

<div id="orgf850f5b" class="outline-3">
<h3 id="二叉树数据结构"><a id="orgf850f5b"></a>5. 二叉树数据结构</h3>
<div class="outline-text-3" id="text-二叉树数据结构">
<ul class="org-ul">
<li>直接用结点构造的二叉树具有递归结构，可以很方便地递归处理。但有不统一的地方：

<ul class="org-ul">
<li>用 None 表示空树，但 None 不具有 BitNode 类型</li>
</ul></li>

<li>解决方法是定义一个二叉树类型，以结点树作为其内部表示</li>
<li><p>
程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">BiTree</span><span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">object</span><span style="color: #2aa198;">)</span>:

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>._root = <span style="color: #268bd2; font-weight: bold;">None</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">is_empty</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span>  <span style="color: #859900; font-weight: bold;">self</span>._root == <span style="color: #268bd2; font-weight: bold;">None</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_root</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, rootnode<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>._root = rootnode

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_left</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, leftchild<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>._root.left = leftchild
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">set_right</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, rightchild<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>._root.right = rightchild

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">root</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:<span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._root
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">leftchild</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:<span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._root.left
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">rightchild</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:<span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._root.right
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="orgfc8b1e8" class="outline-2">
<h2 id="八哈夫曼树"><a id="orgfc8b1e8"></a>八、哈夫曼树</h2>
<div class="outline-text-2" id="text-八哈夫曼树">
<ul class="org-ul">
<li>是一种二叉树，在信息领域有重要理论和实际价值</li>
<li>考虑带权扩充二叉树的"外部路径长度"。这种二叉树的外部结点（叶结点）标有一个权值，称为该结点的权，表示与该叶有关的某种性质</li>
<li>扩充二叉树的外部路径长度： \[E=\sum_{i=1}^ml_i\]
$l_i$：从根到外部结点i的路径长度 m：外部结点个数</li>
<li>带权外部路径长度： \[WPL=\sum_{i=1}^mw_il_i\] $w_i$：外部结点i的权</li>
</ul>
</div>

<div id="org04a1592" class="outline-3">
<h3 id="定义-1"><a id="org04a1592"></a>1. 定义</h3>
<div class="outline-text-3" id="text-定义-1">
<ul class="org-ul">
<li>有实数集 W={\(w_1,w_2,...,w_m\)}，T 是一棵扩充二叉树，包含m个分别以
\(w_i\)(i=1,2,&#x2026;,m) 为权的外部结点，且其带权外部路径长度 WPL
达到最小，则称 T 为数据集W的最优二叉树或哈夫曼树</li>
<li>以同一集实数为外部结点权的二叉树，WPL 可能不同</li>
</ul>
</div>
</div>

<div id="org671507e" class="outline-3">
<h3 id="哈夫曼算法"><a id="org671507e"></a>2. 哈夫曼算法</h3>
<div class="outline-text-3" id="text-哈夫曼算法">
<ul class="org-ul">
<li>输入实数集 W={\(w_1,w_2,...,w_m\)}

<ul class="org-ul">
<li>构造中维护包含 m 棵二叉树的集合 F，开始时
F={\(T_1,T_2,...,T_M\)}，其中 \(T_i\) 是只把韩权为 \(w_i\)
的根结点的单点二叉树</li>
<li>重复如下步骤，直到F中只含一棵树为止

<ul class="org-ul">
<li>从 F
中选取两棵权最小的树作为左右子树，构造一棵新的二叉树，设置其根结点权值为两棵子树根结点的权值之和</li>
<li>从 F 中删除所选的两棵树，把新构造的二叉树加入 F</li>
</ul></li>
</ul></li>

<li>集合W上的哈夫曼树不唯一。如果 T 是 W
上的哈夫曼树，交换T的左右子树，依然是。</li>
</ul>
</div>
</div>

<div id="org6a822d6" class="outline-3">
<h3 id="哈夫曼编码"><a id="org6a822d6"></a>3. 哈夫曼编码</h3>
<div class="outline-text-3" id="text-哈夫曼编码">
<ul class="org-ul">
<li>问题：给定基本数据集合： D=[\(d_1,d_2,...,d_n\)] W=[\(w_1,w_2,...,w_n\)]
其中 D 是需要编码的字符集合，W 为 D
中各个字符在实际信息传输中出现的概率。要求为 D
设计一套二进制编码，使得：1）用此编码存储、传输时的平均开销最小；2）对任意不同
\(d_i\) 和 $d_j$，\(d_i\) 编码不是 \(d_j\) 编码的前缀</li>
<li>上述第二个条件使解码时容易判断是否已得到一个字符的编码因为任意字符编码不是另一字符编码的前缀，看到了对应于一个字符的一段编码，就可以确定是该字符</li>
<li>注意：这里考虑的编码优化问题，允许各字符的编码长度不同。</li>
<li>哈夫曼提出的方法是通过构造哈夫曼树实现哈夫曼编码：

<ul class="org-ul">
<li>以字符 \(d_1,d_2,...,d_n\) 作为外部结点的标注，把 \(w_1,w_2,...,w_n\)
作为这 n 个外部结点的权，基于他们构造一棵哈夫曼树</li>
<li>在得到的哈夫曼树中，给所有从一个结点到其左子结点的边标上二进制数字
0；到右子结点的边标上 1</li>
<li>以从根结点到一个叶结点的路径上的二进制数字序列，作为这个叶结点的字符的编码</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="org9a438ce" class="outline-2">
<h2 id="九树"><a id="org9a438ce"></a>九、树</h2>
<div class="outline-text-2" id="text-九树">
<ul class="org-ul">
<li>在一般的状态空间搜索问题里，搜索过程中经历的状态（看作结点）和状态之间的联系（看作边）就形成了一棵"树"，称为"搜索树"。搜索过程就是按某种顺序"遍历"这棵树</li>
<li>由于非空的树总有一个根结点，掌握了根结点也就掌握了以它为根的树，人们常把树t与其根结点统一看待</li>
</ul>
</div>

<div id="orgc19b99f" class="outline-3">
<h3 id="树的表示-1"><a id="orgc19b99f"></a>1. 树的表示</h3>
<div class="outline-text-3" id="text-树的表示-1">
<ul class="org-ul">
<li>常用的树表示方法：

<ul class="org-ul">
<li>子指针表示法，父指针表示法</li>
<li>子表表示法</li>
<li>长子-兄弟表示法（树的二叉树表示法）</li>
</ul></li>

<li>实际上，树林和二叉树之间有一种1-1对应关系。在这种对应下

<ul class="org-ul">
<li>树林可以用二叉树表示</li>
<li>树可以用二叉树的一个子集表示</li>
</ul></li>
</ul>
</div>
</div>

<div id="org5e3d1a8" class="outline-3">
<h3 id="树林与二叉树的对应转换"><a id="org5e3d1a8"></a>2. 树林与二叉树的对应（转换）</h3>
<div class="outline-text-3" id="text-树林与二叉树的对应转换">
<ul class="org-ul">
<li>从树、树林转换为二叉树的步骤：

<ul class="org-ul">
<li>对于相邻的兄弟结点，从左到右，从前一子结点和后一子结点连一条边（对树林，相邻树的根之间也同样连一条边）</li>
<li>对每个非叶结点，只保留从他到最左子结点的边，删去他到其其它子女的边</li>
</ul></li>

<li>经过上述转换，每个非叶结点至多发出两条边：

<ul class="org-ul">
<li>一条到它的第一个子结点，此边看作在二叉树里这个结点到其左子树根结点的边</li>
<li>另一条到他在原来树中的下一个兄弟结点，此边看作在二叉树里该结点到其右子树根结点的边</li>
</ul></li>

<li>二叉树转换到树林（树）

<ul class="org-ul">
<li>如果其结点是父结点的左子树，则将其向右的路径上的各个结点作为其父结点的顺序的各个子结点</li>
<li>去掉原二叉树中各结点到其右子结点的连线</li>
</ul></li>
</ul>
</div>
</div>

<div id="orgc27ff29" class="outline-3">
<h3 id="结点链接表示法"><a id="orgc27ff29"></a>3. 结点链接表示法</h3>
<div class="outline-text-3" id="text-结点链接表示法">
<ul class="org-ul">
<li>具体实现如下：

<ul class="org-ul">
<li>一个树结点用一个存储块表示</li>
<li>在这个存储块里记录树结点本身的信息，还要记录其子树个数</li>
<li>在结点的存储块里保存到它的各子结点的引用</li>
<li>根结点存储块代表整棵树</li>
<li>如果需要，还可以在每个结点里增加一个父结点链接</li>
</ul></li>

<li>该方法的好处是直接，缺点是结点存储块的大小由子结点的个数决定，大小不一</li>
</ul>
</div>
</div>

<div id="org946d7de" class="outline-3">
<h3 id="子表表示法"><a id="org946d7de"></a>4. 子表表示法</h3>
<div class="outline-text-3" id="text-子表表示法">
<ul class="org-ul">
<li>用一个结点数组（或者线性表），每个结点在数组中有一个位置（下标）

<ul class="org-ul">
<li>每个结点关联一个子结点表，其中记录子结点的（数组）位置</li>
<li>结点本身的数据存储在数组的相应位置</li>
</ul></li>

<li>结点表可以用链接表</li>
</ul>
</div>
</div>

<div id="orgc7974c0" class="outline-3">
<h3 id="总结"><a id="orgc7974c0"></a>5. 总结</h3>
<div class="outline-text-3" id="text-总结">
<ul class="org-ul">
<li>实际算法和程序中，树的使用不如二叉树广泛

<ul class="org-ul">
<li>树的结构不规整，结点的子结点个数可能不同，而且没有限制。计算机里表示和处理比较麻烦</li>
<li>表示树结点的存储块大小可能不同，而且可能相差很大，存储管理工作麻烦，时间和空间开销大</li>
<li>需要维护记录结点的子结点个数</li>
<li>动态增减子结点，也会带来更复杂的管理问题</li>
</ul></li>
</ul>
</div>
</div>
</div>
