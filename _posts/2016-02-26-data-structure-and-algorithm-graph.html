---
layout     : post
title      : "《数据结构与算法:python语言描述》之图"
categories : 数据结构与算法
tags       : 数据结构 算法 图
excerpt    : "阅读《数据结构与算法:python语言描述》课件中“图”部分所写笔记"
---
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#一图">一、图</a>
<ul>
<li><a href="#基本概念">1. 基本概念</a></li>
<li><a href="#图的基本操作">2. 图的基本操作</a></li>
<li><a href="#图的表示">3. 图的表示</a></li>
</ul>
</li>
<li><a href="#二图的实现">二、图的实现</a>
<ul>
<li><a href="#邻接矩阵实现">1. 邻接矩阵实现</a></li>
<li><a href="#压缩的邻接矩阵邻接表实现">2. 压缩的邻接矩阵（邻接表）实现</a></li>
</ul>
</li>
<li><a href="#三图算法">三、图算法</a>
<ul>
<li><a href="#图的遍历">1. 图的遍历</a></li>
<li><a href="#深度优先遍历">2. 深度优先遍历</a></li>
<li><a href="#广度优先遍历">3. 广度优先遍历</a></li>
<li><a href="#非递归深度优先遍历">4. 非递归深度优先遍历</a></li>
</ul>
</li>
<li><a href="#四x遍历和生成树">四、X遍历和生成树</a></li>
<li><a href="#五最小生成树">五、最小生成树</a>
<ul>
<li><a href="#kruskal算法">1. Kruskal算法</a></li>
<li><a href="#mst-性质">2. MST 性质</a></li>
<li><a href="#prim算法">3. Prim算法</a></li>
<li><a href="#最小生成树问题的复杂性">4. 最小生成树问题的复杂性</a></li>
</ul>
</li>
<li><a href="#六最短路径">六、最短路径</a>
<ul>
<li><a href="#dijkstra算法">1. Dijkstra算法</a></li>
<li><a href="#各对顶点之间最短距离floyd-算法">2. 各对顶点之间最短距离：Floyd 算法</a></li>
<li><a href="#最短路径算法分析">3. 最短路径算法分析</a></li>
</ul>
</li>
<li><a href="#七aov网">七、AOV网</a>
<ul>
<li><a href="#拓扑排序">1. 拓扑排序</a></li>
<li><a href="#性质">2. 性质</a></li>
<li><a href="#算法分析">3. 算法分析</a></li>
<li><a href="#程序实现书写图片">4. 程序实现（书写图片）</a></li>
</ul>
</li>
<li><a href="#八aoe-网">八、AOE 网</a>
<ul>
<li><a href="#重点理解">1. 重点理解</a></li>
<li><a href="#算法分析-1">2. 算法分析</a></li>
<li><a href="#程序实现书写图片-1">3. 程序实现（书写图片）</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="orgf9e59c4" class="outline-2">
<h2 id="一图"><a id="orgf9e59c4"></a>一、图</h2>
<div class="outline-text-2" id="text-一图">
<ul class="org-ul">
<li>图是一种数学结构，数学里有‘图论'，研究这种拓扑结构</li>
<li>数据结构课程把图看成一类复杂数据结构，用于表示具有各种复杂关系的数据集合。</li>
<li>重点算法

<ul class="org-ul">
<li>图的深度优先搜索与广度优先搜索</li>
<li><code>最小生成树的Prim</code></li>
<li>求单源最短路径的 <code>Dijkstra 算法</code></li>
<li>求所有顶点对之间最短路径的 <code>Floyd 算法</code></li>
<li>拓扑排序</li>
<li>关键路径</li>
</ul></li>
</ul>
</div>

<div id="org28045fc" class="outline-3">
<h3 id="基本概念"><a id="org28045fc"></a>1. 基本概念</h3>
<div class="outline-text-3" id="text-基本概念">
<ul class="org-ul">
<li>一个图是一个二元组 G=(V,E),其中：

<ul class="org-ul">
<li>V 是顶点的非空有穷集合（也可以有空图的概念，但用处不大）</li>
<li>E 是顶点偶对（称为边）的集合，E⊆VxV</li>
<li>V 中顶点也称为图 G 的顶点，E 中的边也称为图 G 的边</li>
</ul></li>

<li><b><code>有向图&amp;无向图</code></b>

<ul class="org-ul">
<li>有向图：有向图中的边有方向，边是顶点的有序对 有序对用尖括号表示。&lt;
vi , vj &gt; 表示从 vi 到 vj 的有向边，vi 称为边的始点，vj
是边的终点。&lt; vi , vj &gt; 和 &lt; vj , vi &gt; 是不同的两条有向边</li>
<li>无向图：无向图中的边没有方向，是顶点的无序对无序对用圆括号表示，(vi,vj) 和 (vj,vi) 表示同一条无向边</li>
</ul></li>
</ul>
</div>

<div id="org71ab51e" class="outline-4">
<h4 id="a.-概念与性质"><a id="org71ab51e"></a>a. 概念与性质</h4>
<div class="outline-text-4" id="text-a.-概念与性质">
<ul class="org-ul">
<li>如果 G 里有边 &lt; vi , vj &gt;⊆E（或 (vi,vj)⊆E）

<ul class="org-ul">
<li>顶点 vj 称为 vi 的邻接顶点（对无向图，邻接点事双向的）</li>
<li>这种边称为与顶点 vi 相关联的边或 vi 的邻接边</li>
</ul></li>

<li>图可用图形自然表示（圆圈表示顶点，线段或箭头表示边）

<ul class="org-ul">
<li>不考虑顶点到自身的边</li>
<li>顶点间没有重复出现的边</li>
</ul></li>

<li>完全图：任意两顶点之间都有边的图。显然：

<ul class="org-ul">
<li>n 个顶点的=无向完全图有 n*(n-1)/2 条边=</li>
<li>n 个顶点的=有向完全图有 n*(n-1) 条边=</li>
</ul></li>

<li>注意一个重要事实：|E|≤|V|2，也即 |E|=O(V|2)
也就是说，边的条数可能达到顶点数的平方</li>
<li><b><code>度（顶点的度）</code></b>
与一个顶点邻接的边的条数。对有向图，度数还进一步分为入度和出度，分别表示以该顶点为始点或者终点的边的条数</li>
<li>顶点数 n，边数 e 和度数满足如下关系： 边数等于各顶点度数之和的一半</li>
<li><b><code>路径</code></b> 对于图 G=(V,E)，如果存在顶点序列 vi0,vi1&#x2026;vim，使得
(vi0,vi1),(vi1,vi2)&#x2026;(vi(m-1),vim) 都在 E 中（都是 G
的边，对于有向图是 &lt; vi0,vi1 &gt;,&lt; vi1,vi2 &gt;&#x2026;&lt; vi(m-1),vim &gt; 都在 E
中）

<ul class="org-ul">
<li>则说从顶点 vi0 到 vim 存在一条路径</li>
<li>&lt; vi0,vi1&#x2026;vim &gt; 称为是从 vi0 到 vim 的路径</li>
</ul></li>

<li><b><code>路径长度</code></b> 路径上边的条数</li>
<li><b><code>回路（环）</code></b>
起点和终点相同的路径。如果除起点和终点外的其他顶点均不相同，则称为简单回路</li>
<li><b><code>简单路径</code></b>
内部不包含回路的路径，即路径上的顶点除起点和终点可能相同外，其它顶点均不相同，简单回路也是简单路径</li>
<li><b><code>子图</code></b> 对图 G=(V,E) 和 G'=(V',E')，如果 V'⊆V且E'⊆E，就称 G' 是 G
的子图。特别低，G 是自身的子图</li>
<li><b><code>有根图</code></b> 有向图 G 里存在一个顶点 v，从 v 到图 G
中其它每个顶点均有路径，则称 G 为一个有根图，称 v 为图 G
的一个根。有根图中的根可能不唯一</li>
<li><b><code>连通性</code></b> 如果无向图 G 中有从 vi 到 vj
的路径，则称它们是连通的（顶点到自身默认连通）

<ul class="org-ul">
<li>无向图 G 的连通性：

<ul class="org-ul">
<li>连通图：若 G 中任意两不同顶点之间都连通，则称 G 为一个连通图</li>
<li>G 的极大连通子图（连通分量）G' 是 G 的连通子图，且 G 中没有包含 G'
的连通子图。若 G 不连通，则其连通分量多于一个</li>
<li>G 的连通分量形成了 <code>G</code> 的一个划分</li>
</ul></li>

<li>有向图 G 的连通性:

<ul class="org-ul">
<li>强连通图：若 G 中任意两不同顶点之间都有路径，则称 G 为一个强连通图</li>
<li>强连通分量：G 的极大强连通子图</li>
<li>G 的连通分量形成其=顶点=的一个划分</li>
</ul></li>
</ul></li>

<li><b><code>带权图</code></b> 图中的每条边都被赋予一个权值

<ul class="org-ul">
<li>权值可用于表示实际应用中与顶点关联有关的某些信息</li>
<li>带权的连通无向图称为网络</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="orgc8b700c" class="outline-3">
<h3 id="图的基本操作"><a id="orgc8b700c"></a>2. 图的基本操作</h3>
<div class="outline-text-3" id="text-图的基本操作">
<ul class="org-ul">
<li>创建图，创建空图，或基于顶点和边的数据创建图</li>
<li>顶点的个数（vertex\<sub>num</sub>)和边的条数</li>
<li>所有顶点的集合 vertices，所有边的集合 edges</li>
<li>增加一条边 &lt;v1,v2&gt; 或 (v1,v2)，是否存在边 &lt;v1,v2&gt; 或
(v1,v2)，get\<sub>edge</sub>(g,v1,v2)</li>
<li>顶点 v 的入度和出度(结果用二元序列表示)，vdegree(v)</li>
<li>找出顶点 v 相邻边(集合或表)，如出边 out\<sub>edges</sub>(v)</li>
</ul>
</div>

<div id="orgf4ad7e2" class="outline-4">
<h4 id="a.-遍历操作"><a id="orgf4ad7e2"></a>a. 遍历操作</h4>
<div class="outline-text-4" id="text-a.-遍历操作">
<ul class="org-ul">
<li>与树遍历的最重要差异是：

<ul class="org-ul">
<li>需要防止再次进入已经遍历过的部分</li>
<li>需要考虑图的连通性问题（若图不连通，遍历完一个连通分支，还要继续遍历其它连通分支）</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="org99f67f3" class="outline-3">
<h3 id="图的表示"><a id="org99f67f3"></a>3. 图的表示</h3>
<div class="outline-text-3" id="text-图的表示">
<ul class="org-ul">
<li>图的结构比较复杂，任意两个顶点间都可能存在边

<ul class="org-ul">
<li>需要表示顶点及顶点间的边，存在很多可能的方法</li>
<li>应该根据具体应用和需要做的操作等选择图的表示方法</li>
</ul></li>

<li>图的最基本表示方法是邻接矩阵表示法。表示图中邻接关系的矩阵通常非常稀疏，空间浪费可能很大。很多图中边数与顶点数成线性关系，如中国铁路线路图。为降低空间代价，人们提出需要可看做邻接矩阵的'压缩‘b的方法：

<ul class="org-ul">
<li>邻接表表示法</li>
<li>邻接多重表表示法</li>
<li>图的十字链表表示，等</li>
</ul></li>
</ul>
</div>

<div id="orgf22984a" class="outline-4">
<h4 id="a.-邻接矩阵表示法"><a id="orgf22984a"></a>a. 邻接矩阵表示法</h4>
<div class="outline-text-4" id="text-a.-邻接矩阵表示法">
<ul class="org-ul">
<li>邻接矩阵就是一个表示图中顶点间邻接关系的方阵，设 G=(V,E) 为 n
个顶点的图，其邻接矩阵如下矩阵 A:</li>
</ul>

<p>
\[  A[i,j] =
\begin{cases}
1,  & {若(v_i,v_j)或<v_i,v_j>是图G的边} \\
o, & {若(v_i,v_j)或<v_i,v_j>不是图G的边}
\end{cases}\]
</p>

<ul class="org-ul">
<li>邻接矩阵只表示图中顶点个数和顶点间联系（边）

<ul class="org-ul">
<li>每个顶点对应一个矩阵下标</li>
<li>通过一对下标可以确定图中一条边的有无</li>
</ul></li>

<li>若顶点本身还有其他信息，就需要另外的方式表示顶点信息

<ul class="org-ul">
<li>例如，可以考虑另外用一个顶点表</li>
<li>可以用与矩阵同样下标引用同一顶点的表元素</li>
</ul></li>

<li><p>
下面无向图G1的邻接矩阵，无向图的邻接矩阵总是对称矩阵
</p>

<pre class="example">
v0------------ v3
|   、     /
|       、
|   /        、
v1------------v4
</pre>

<p>
$$
</p>
\begin{Bmatrix}
0 & 1 & 1 & 1 \\
1 & 0 & 1 & 1 \\
1 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 \\
\end{Bmatrix}
<p>
$$
</p></li>

<li><p>
带权图的边附带有用信息，用邻接矩阵表示时，可以把权信息记录在矩阵里。矩阵元素是边的权值，无边的情况另行表示。wij
是边的权
</p>

<p>
\[  A[i,j] =
    \begin{cases}
    w_{ij},  & {若(v_i,v_j)或<v_i,v_j>是图G的边} \\
    o, & {若(v_i,v_j)或<v_i,v_j>不是图G的边}
    \end{cases}\]
</p></li>
</ul>
</div>
</div>

<div id="org5c5f823" class="outline-4">
<h4 id="b.-邻接表表示法"><a id="org5c5f823"></a>b. 邻接表表示法</h4>
<div class="outline-text-4" id="text-b.-邻接表表示法">
<ul class="org-ul">
<li>与树的'子表表示'类似

<ul class="org-ul">
<li>一个顶点表用来表示图中顶点及其相关信息</li>
<li>顶点表中每个顶点关联着一个邻接表，记录其邻接顶点</li>
</ul></li>

<li>无向图

<ul class="org-ul">
<li>一个顶点表，每个顶点有一个邻接边的表</li>
<li>边 (vi，vj) 在顶点 vi，vj 的边表各有一结点，在边表中存储两次</li>
<li>顶点 vi 的边表中结点个数等于其度数</li>
</ul></li>

<li>有向图

<ul class="org-ul">
<li>一个顶点表，每个顶点关联着一个边表</li>
<li>顶点 vi 的边表里每个结点对应的是以 vi
为始点的一条边，因此可称为出边表</li>
<li>顶点 vi 的边表中结点个数等于其出度</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="org6cdcb48" class="outline-2">
<h2 id="二图的实现"><a id="org6cdcb48"></a>二、图的实现</h2>
<div class="outline-text-2" id="text-二图的实现">
<ul class="org-ul">
<li>在 python 里实现图数据结构有很多方法

<ul class="org-ul">
<li>例如用 list 的 list（或 tuple 的
tuple）直接实现邻接矩阵。使用方便，判邻接简单，但存储代价较大，不适合较大的图</li>
<li>用字典从下标序对映射到邻接边的值。检索效率高，适合稀疏矩阵（邻接矩阵常如此）。字典实现复杂</li>
<li>用 python 内置的 Bytes 字节向量类似或标准库的 array
类型。前者存储效率高，可能用于实现很大的图，编程复杂一些；后者可以表示整数或浮点权值的带权图，编程也标记复杂</li>
<li>自定义类型实现邻接表表示，下面考虑两种简单技术</li>
</ul></li>

<li>下面假定有一个全局变量 infinity
表示无穷大，如果带权图中不同的两顶点间无边，就以 infinity
作为边的权值，infinity=float("inf")</li>
</ul>
</div>

<div id="org0d5f8fc" class="outline-3">
<h3 id="邻接矩阵实现"><a id="org0d5f8fc"></a>1. 邻接矩阵实现</h3>
<div class="outline-text-3" id="text-邻接矩阵实现">
<ul class="org-ul">
<li>实现问题：

<ul class="org-ul">
<li>矩阵元素可以是1或权值表示边，用一个特殊值表示"无联"</li>
<li>假设用户提供一个unconn值，默认为0</li>
<li>构造函数基于给定的矩阵参数建立一个图</li>
</ul></li>

<li><p>
程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Graph</span><span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">object</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, mat, unconn = <span style="color: #6c71c4;">0</span><span style="color: #2aa198;">)</span>:
        <span style="color: #268bd2;">vnum1</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>mat<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> vnum1:
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span> != vnum1:
                <span style="color: #859900; font-weight: bold;">raise</span> <span style="color: #b58900;">ValueError</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Argument for 'GraphA' is bad."</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">self</span>.mat = <span style="color: #2aa198;">[</span>mat<span style="color: #b58900;">[</span>i<span style="color: #b58900;">][</span>:<span style="color: #b58900;">]</span> <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #b58900;">(</span>vnum1<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
        <span style="color: #859900; font-weight: bold;">self</span>.unconn = unconn
        <span style="color: #859900; font-weight: bold;">self</span>.vnum = vnum1

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">vertex_num</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.vnum
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_edge</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, vi, vj, val = <span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum <span style="color: #859900; font-weight: bold;">and</span> <span style="color: #6c71c4;">0</span> &lt;= vj &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">][</span>vj<span style="color: #2aa198;">]</span> = val
    <span style="color: #586e75;"># </span><span style="color: #586e75;">&#19981;&#25903;&#25345;&#22686;&#21152;&#39030;&#28857;&#65292;&#33509;&#35201;&#25903;&#25345;&#65292;&#36824;&#38656;&#27599;&#34892;&#22686;&#21152;&#20803;&#32032;&#65292;&#27604;&#36739;&#40635;&#28902;</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_vertex</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">raise</span> AdjGraphError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Adjacent Matrix does not support 'add_vertex'"</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_edge</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, vi, vj<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum <span style="color: #859900; font-weight: bold;">and</span> <span style="color: #6c71c4;">0</span> &lt;= vj &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">][</span>vj<span style="color: #2aa198;">]</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">out_edges</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>,vi<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>._out_edges<span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.mat, vi, <span style="color: #859900; font-weight: bold;">self</span>.unconn<span style="color: #2aa198;">)</span>

    <span style="color: #586e75;"># </span><span style="color: #586e75;">&#23450;&#20041;&#20026;&#38745;&#24577;&#26041;&#27861;&#65292;&#21487;&#33021;&#22312;&#20854;&#20182;&#22320;&#26041;&#20351;&#29992;    </span>
    @<span style="color: #839496; font-weight: bold;">staticmethod</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">_out_edges</span><span style="color: #2aa198;">(</span>mat, vi, unconn<span style="color: #2aa198;">)</span>:
        <span style="color: #268bd2;">edges</span> = <span style="color: #2aa198;">[]</span>, <span style="color: #268bd2;">row</span> = mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">]</span>
        <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>row<span style="color: #2aa198;">)</span>:
            <span style="color: #859900; font-weight: bold;">if</span> row<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> != unconn:
                edges.append<span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>i,row<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">]</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> edges

    <span style="color: #586e75;"># </span><span style="color: #586e75;">&#20869;&#32622;&#20989;&#25968;str()&#35843;&#29992;&#23427;&#29983;&#20135;Graph&#23545;&#35937;&#30340;&#23383;&#31526;&#20018;&#34920;&#31034;&#65292;&#29992;&#20110;&#23384;&#20837;&#25991;&#20214;&#25110;&#36755;&#20986;</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__str__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #2aa198;">"[\n"</span> + <span style="color: #2aa198;">"\n"</span>.join<span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">map</span><span style="color: #b58900;">(</span><span style="color: #839496; font-weight: bold;">str</span>, <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span> + <span style="color: #2aa198;">"\n]\n"</span>\
            + <span style="color: #2aa198;">"Unconnected:"</span> + <span style="color: #839496; font-weight: bold;">str</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.unconn<span style="color: #2aa198;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="org4db28f2" class="outline-3">
<h3 id="压缩的邻接矩阵邻接表实现"><a id="org4db28f2"></a>2. 压缩的邻接矩阵（邻接表）实现</h3>
<div class="outline-text-3" id="text-压缩的邻接矩阵邻接表实现">
<ul class="org-ul">
<li>邻接矩阵表示的缺点是空间复杂性与结点数的平方成正比，有时矩阵中大部分元素是
infinity（或者 0）</li>
<li>考虑一种'压缩'表示形式：

<ul class="org-ul">
<li>每个顶点的邻接边用一个 list 表示，元素形式为(wj,w)，wj 是边的终点，w
是边的信息</li>
<li>整个图就是这种 list 的 list，每个元素对应一个顶点</li>
<li>很容易添加顶点</li>
<li>可以采用与前面 Graph 同样的接口，定义同样名字的方法，</li>
<li>内部表示采用新的一套，一些方法可以继承</li>
</ul></li>

<li><p>
程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">GraphA</span><span style="color: #2aa198;">(</span>Graph<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, mat, unconn = <span style="color: #6c71c4;">0</span><span style="color: #2aa198;">)</span>:
        <span style="color: #268bd2;">vnum1</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>mat<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> mat:
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span> != vnum1:
                <span style="color: #859900; font-weight: bold;">raise</span> <span style="color: #b58900;">ValueError</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Argument for 'GraphA' is bad."</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">self</span>.mat = <span style="color: #2aa198;">[</span>Graph._out_edges<span style="color: #b58900;">(</span>mat, i, unconn<span style="color: #b58900;">)</span> <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #b58900;">(</span>vnum1<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
        <span style="color: #859900; font-weight: bold;">self</span>.vnum = vnum1
        <span style="color: #859900; font-weight: bold;">self</span>.unconn = unconn

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_vertex</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.mat.append<span style="color: #2aa198;">(</span><span style="color: #b58900;">[]</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">self</span>.vnum += <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.vnum -<span style="color: #6c71c4;">1</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">add_edge</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, vi, vj, val = <span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum <span style="color: #859900; font-weight: bold;">and</span> <span style="color: #6c71c4;">0</span> &lt;= vj &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #268bd2;">row</span> = <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">]</span>
        <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #2aa198;">(</span><span style="color: #839496; font-weight: bold;">len</span><span style="color: #b58900;">(</span>row<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>:
            <span style="color: #859900; font-weight: bold;">if</span> row<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span> == vj:
                <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">][</span>vj<span style="color: #2aa198;">]</span> = <span style="color: #2aa198;">(</span>vj, val<span style="color: #2aa198;">)</span>
                <span style="color: #859900; font-weight: bold;">return</span>
            <span style="color: #859900; font-weight: bold;">if</span> row<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span><span style="color: #6c71c4;">0</span><span style="color: #2aa198;">]</span> &gt; vj:
                <span style="color: #859900; font-weight: bold;">break</span>
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #268bd2;">i</span> += <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">]</span>.insert<span style="color: #2aa198;">(</span>i, <span style="color: #b58900;">(</span>vj, val<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
    <span style="color: #586e75;"># </span><span style="color: #586e75;">&#36825;&#37324;&#29992;&#39034;&#24207;&#26816;&#32034;&#25554;&#20837;/&#35775;&#38382;&#65292;&#32467;&#28857;&#30340;&#20986;&#24230;&#24456;&#23567;&#26102;&#25805;&#20316;&#30340;&#25928;&#29575;&#19981;&#26159;&#38382;&#39064;&#12290;&#22914;&#26524;&#32467;&#28857;&#20986;&#24230;&#24456;&#22823;&#65292;&#21487;&#20197;&#32771;&#34385;&#29992;&#20108;&#20998;&#26816;&#32034;&#65292;&#25110;&#20026;&#27599;&#20010;&#32467;&#28857;&#20851;&#32852;&#19968;&#20010;dict&#65292;&#20197;&#25903;&#25345;&#24555;&#36895;&#25554;&#20837;&#21644;&#35775;&#38382;</span>

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">get_edge</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, vi, vj<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum <span style="color: #859900; font-weight: bold;">and</span> <span style="color: #6c71c4;">0</span> &lt;= vj &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #859900; font-weight: bold;">for</span> i , val <span style="color: #859900; font-weight: bold;">in</span> mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">]</span>:
            <span style="color: #859900; font-weight: bold;">if</span> i == vj:
                <span style="color: #859900; font-weight: bold;">return</span> val
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.unconn

    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">out_egdes</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, vi<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">assert</span> <span style="color: #6c71c4;">0</span> &lt;= vi &lt;= <span style="color: #859900; font-weight: bold;">self</span>.vnum
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.mat<span style="color: #2aa198;">[</span>vi<span style="color: #2aa198;">]</span>
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="org3e92338" class="outline-2">
<h2 id="三图算法"><a id="org3e92338"></a>三、图算法</h2>
<div class="outline-text-2" id="text-三图算法">
<ul class="org-ul">
<li>很多实际问题可以归结为图和图上的计算

<ul class="org-ul">
<li>网络路由</li>
<li>集成电路的设计和布线</li>
<li>运输和物流中的各种规划安排问题</li>
<li>工程项目的计划安排</li>
<li>许多社会问题计算，如金融监管</li>
</ul></li>

<li>一旦从应用中抽象出'图'，应用问题的解决就可能变成图算法问题</li>
</ul>
</div>

<div id="orge1dfca6" class="outline-3">
<h3 id="图的遍历"><a id="orge1dfca6"></a>1. 图的遍历</h3>
<div class="outline-text-3" id="text-图的遍历">
<ul class="org-ul">
<li>遍历：按某种方式系统访问图中所有顶点且每个顶点仅访问一次的过程，也称为图的周游。前面讨论的状态空间中的状态和相邻关系就形成了一个图，图的遍历对应于一次穷尽的状态空间搜索</li>
<li>遍历的基本部分是访问以顶点所在连通分支的全部顶点。如果图不连通，还要考虑对其他部分的访问

<ul class="org-ul">
<li>基本的图遍历方法同样是深度优先遍历和宽度优先遍历</li>
</ul></li>
</ul>
</div>
</div>

<div id="org149ff16" class="outline-3">
<h3 id="深度优先遍历"><a id="org149ff16"></a>2. 深度优先遍历</h3>
<div class="outline-text-3" id="text-深度优先遍历">
<ul class="org-ul">
<li>按照深度优先搜索（Depth&#x2014;First Search）的方式遍历，做法是：

<ul class="org-ul">
<li>从指定顶点 v 出发，先访问 v（并将其标记为已访问）</li>
<li>从 v
的未访问过的邻接顶点出发进行深度优先搜索（邻接顶点可能排一种顺序），直到与v连通的所有顶点都已访问（递归）</li>
<li>如果图中还有未访问的顶点，则选出一个，由它出发，重复上述过程，直至图中所有顶点访问完</li>
</ul></li>

<li>通过深度优先遍历顺序得到的顶点序列称为该图的深度优先搜索序列，简称 DFS
序列

<ul class="org-ul">
<li>对邻接点的不同访问顺序就得到不同的 DFS 序列（不唯一）</li>
<li>如果规定了图中各顶点的邻接点顺序，就确定了 DFS 序列</li>
</ul></li>
</ul>
</div>
</div>

<div id="org7867ca8" class="outline-3">
<h3 id="广度优先遍历"><a id="org7867ca8"></a>3. 广度优先遍历</h3>
<div class="outline-text-3" id="text-广度优先遍历">
<ul class="org-ul">
<li>通过广度优先搜索（Breadth-First Search）方式遍历，做法是：

<ul class="org-ul">
<li>从指定顶点 v 出发，先访问 v（并将其标记为已访问） *依次访问 v
的所有邻接顶点 v1，v2&#x2026;vm（可按顺序），再依次访问与 v1，v2&#x2026;vm
邻接的所有未访问顶点，直到所有顶点都访问完</li>
<li>如果图中还有未访问的顶点，则选出一个，由它出发，重复上述过程，直至图中所有顶点访问完</li>
</ul></li>

<li>通过广度优先搜索遍历得到的顶点序列称为该图的广度优先搜索序列，简称为
BFS 序列

<ul class="org-ul">
<li>如果规定了图中各顶点的邻接点顺序，BFS 序列就确定了</li>
</ul></li>
</ul>
</div>
</div>

<div id="org79cf4a5" class="outline-3">
<h3 id="非递归深度优先遍历"><a id="org79cf4a5"></a>4. 非递归深度优先遍历</h3>
<div class="outline-text-3" id="text-非递归深度优先遍历">
</div>

<div id="org52317c5" class="outline-4">
<h4 id="a.-程序实现"><a id="org52317c5"></a>a. 程序实现</h4>
<div class="outline-text-4" id="text-a.-程序实现">
<pre class="example">
```python
def DFS_graph(graph, v0):
    vnum = graph.vertex.num
    visited = [0]*vnum
    visited[v0] = 1
    DFS_seq = [v0]
    st = SStack()
    st.push((0, graph._out_egdes(vo)))
    while not st.is_empty:
        i, edges = st.pop()
        if i &lt; len(edges):
            v, e = edges[i]
            st.push((i+1, edges))
            if not visited[v]:
                DFS_seq.append(v)
                visited[v] = 1
                st.push((0, graph._out_edges(v)))
    return DFS_seq
```
</pre>
</div>
</div>

<div id="orgae7d4b0" class="outline-4">
<h4 id="b.-x复杂性分析"><a id="orgae7d4b0"></a>b. X复杂性分析</h4>
<div class="outline-text-4" id="text-b.-x复杂性分析">
</div>
</div>
</div>
</div>

<div id="orgd354b31" class="outline-2">
<h2 id="四x遍历和生成树"><a id="orgd354b31"></a>四、X遍历和生成树</h2>
<div class="outline-text-2" id="text-四x遍历和生成树">
</div>
</div>

<div id="org8334b44" class="outline-2">
<h2 id="五最小生成树"><a id="org8334b44"></a>五、最小生成树</h2>
<div class="outline-text-2" id="text-五最小生成树">
<ul class="org-ul">
<li>网络
G（带权连通无向图）的每条边带有给定的权值，它的一棵生成树中各条边的权值之和称为该生成树的权</li>
<li>网络 G 可能有很多棵生成树，其权值可能不同。其中权值最小的生成树称为 G
的最小生成树（Minimum Spanning Tree，MST)

<ul class="org-ul">
<li>显然，网络必有最小生成树，但可能不唯一</li>
</ul></li>

<li>最小生成树有很多实际应用：

<ul class="org-ul">
<li>顶点看作城市，边的权看作城市之间的通讯成本，根据最小生成树建立的是城市间成本最低的通讯网</li>
<li>可以考虑成本最低的公路网；输电网；城市配送中心与线路规划；集成电路或印刷电路板的地线、供电线路等等</li>
</ul></li>

<li>表示这类应用的带权图中各结点到自身的权应取0，到其他结点有边时有具体的权值，无边时取无穷大
infinity。下面的算法均如此假定</li>
</ul>
</div>

<div id="org24a3528" class="outline-3">
<h3 id="kruskal算法"><a id="org24a3528"></a>1. Kruskal算法</h3>
<div class="outline-text-3" id="text-kruskal算法">
<ul class="org-ul">
<li>设 G=(V,E) 是一个网络，算法过程如下：

<ul class="org-ul">
<li>初始时只取包含 G 中 n 个顶点而无边的孤立点子图 T=(V,{})，T
中每个顶点自成一个连通分量。下面考虑T的扩充</li>
<li>将 E 中的边按权的递增顺序排序</li>
<li>构造中每步按从小到大的顺序选一条两端点位于T中不同连通分量的边 e，把
e 加入 T。由于 e
将两顶点连接，因此两个不同连通分量合成一个（每次操作减少一个连通分量）</li>
<li>不断重复加入新边，直到T中所有顶点都包含在一个连通分量，该连通分量就是
G 的一棵最小生成树</li>
<li>若上述操作最终得不到一个包含 G
中所有顶点的连通分量，则原图不连通，无最小生成树。算法做出的是 G
的最小连通树林</li>
</ul></li>
</ul>
</div>

<div id="orgfa4bd2b" class="outline-4">
<h4 id="a.-算法分析"><a id="orgfa4bd2b"></a>a. 算法分析</h4>
<div class="outline-text-4" id="text-a.-算法分析">
<ul class="org-ul">
<li>关键是连通分量的判定，可建立一个表来记录与维护每个顶点的连通分量，初始时各顶点的连通分量为顶点自身为代表</li>
</ul>
</div>
</div>

<div id="org0a9f676" class="outline-4">
<h4 id="b.-程序实现"><a id="org0a9f676"></a>b. 程序实现</h4>
<div class="outline-text-4" id="text-b.-程序实现">
<pre class="example">
```python
def Kruskal(graph):
    vnum = graph.vertex_num()
    reps = [i for i in range(vnum)]
    mst, edges = [], []
    for vi in range(vnum):
        for v, w in graph._out_edges(vi):
            edges.append((w, (vi, v)))
    edges.sort()
    for w, e in edges:
        if reps[e[0]] != reps[e[1]]:
            mst.append((e, w))
            if len(mst) == vnum-1
                break
            rep, orep = resp[e[0]], reps[e[1]]

            for i in range(vnum):
            # 把顶点v所在连通分量上各顶点的连通分量属性设置为顶点vi的连通分量属性，可互换
                if reps[i] == orep:
                    resp[i] = rep
    return mst
```
</pre>
</div>
</div>

<div id="org2ff4ac9" class="outline-4">
<h4 id="c.-x复杂性分析"><a id="org2ff4ac9"></a>c. X复杂性分析</h4>
<div class="outline-text-4" id="text-c.-x复杂性分析">
</div>
</div>
</div>

<div id="org31ec5ad" class="outline-3">
<h3 id="mst-性质"><a id="org31ec5ad"></a>2. MST 性质</h3>
<div class="outline-text-3" id="text-mst-性质">
<ul class="org-ul">
<li>设 G=(V,E) 是网络，U 是 V 的任一真子集，e=(u,v)∈E 且 u∈U，v∈V-U，而且
e 在 G 中所有一个端点在 U 另一端点在 V-U 的边中权值最小，那么 G
必有一棵包含边 e 的最小生成树</li>
</ul>
</div>
</div>

<div id="org8e6a74b" class="outline-3">
<h3 id="prim算法"><a id="org8e6a74b"></a>3. Prim算法</h3>
<div class="outline-text-3" id="text-prim算法">
<ul class="org-ul">
<li>基本思想：从一个顶点出发，利用 MST
性质选最短连接边扩充已连接的顶点集，直至该集合包含了所有顶点或最终确定不是连通图</li>
<li>算法细节：

<ul class="org-ul">
<li>从图 G 的顶点集V中任选取一顶点 V0 放入集合 U 中，此时 U={V0}，边集合
TE={}，T=(U,TE) 是一棵树</li>
<li>检查所有一个顶点在集合 U 里另一个顶点在集合 V-U 的边，找出权值最小边
e=(u,v)(u∈U,v∈V-U)，将顶点 v 加入到集合 U，并将 e 加入到 TE，T
依然是一棵树。</li>
<li>重复上面步骤直至 U=V。此时 TE 有 n-1 条边，T 就是 G 的一棵最小生成树</li>
</ul></li>

<li>生成树用类似构造 DFS 生成树的数据表示，用 vnum 个元素的表 mst
保存最小生成树的边，mst[1]=((1,3),10) 表示顶点 1 到 3 的边在 mst
且权值为 10，mst[i] = None 表示 i 不属于 U。</li>
<li>用一个优先队列 cands 记录候选的最短边，元素形式为（w,i,j)，表示从顶点
i 到 j 的边为候选，其权值为 w</li>
</ul>
</div>

<div id="orgbe21256" class="outline-4">
<h4 id="a.-算法过程"><a id="orgbe21256"></a>a. 算法过程</h4>
<div class="outline-text-4" id="text-a.-算法过程">
<ul class="org-ul">
<li>初始把（0,0,0)放入优先队列，表示从顶点 0 到自身的长 0 的边</li>
<li>循环的第一次迭代将把顶点 0 记入最小生成树顶点集 U，方法是设 mst[0] =
(0,0)。同时把顶点 0 到其余顶点的边按权值存入优先队列
cands，表示待考察的候选边集合</li>
<li>执行中反复选择 cands 里记录的最短边 (u,v)。如确定它是连接 U 中顶点与
V-U 中顶点的边，就把这条边及其权记入 must[v]，并把 v 的出边存入
cands，否则直接丢掉</li>
<li>结束时 mst 是最小生成树的 n 条边（包括（0，0）边以方便实现）</li>
</ul>
</div>
</div>

<div id="org8c895e9" class="outline-4">
<h4 id="b.-程序实现-1"><a id="org8c895e9"></a>b. 程序实现</h4>
<div class="outline-text-4" id="text-b.-程序实现-1">
<pre class="example">
```python
def Prim(graph):
    vnum = graph.vertex_num()
    mst = [None]*vnum
    cands = PriQueue([(0, 0, 0)])
    count = 0
    while count &lt; vnum and not cands.is_empty:
        w, v, vmin = cands.dequeue()
        if mst[vmin]:
            contunue # 回到循环开始处
        count += 1
        mst[vmin] = ((vmin, v), w)
        for edge in graph.out_edges(vmin):
            v, w = edge
            if not mst[v]:
                cands.enqueue(w, vmin, v)
    return mst
```
</pre>
</div>
</div>

<div id="org3286c18" class="outline-4">
<h4 id="c.-x复杂性分析-1"><a id="org3286c18"></a>c. X复杂性分析</h4>
<div class="outline-text-4" id="text-c.-x复杂性分析-1">
</div>
</div>

<div id="org1636bd6" class="outline-4">
<h4 id="d.-prim算法改进"><a id="org1636bd6"></a>d. prim算法改进</h4>
<div class="outline-text-4" id="text-d.-prim算法改进">
<ul class="org-ul">
<li>若新加入顶点的邻接边对应的顶点 v 的权值 w 比已存入堆中包含 v
顶点邻接边的权值小则将堆中顶点 v 的邻接边替换为新的更小的并重排堆</li>
<li>若顶点还没确定邻接边，则其邻接边权值为 infinity 无穷大，表示无邻接边</li>
</ul>
</div>
</div>

<div id="orgd32d819" class="outline-4">
<h4 id="e.-x改进后程序实现"><a id="orgd32d819"></a>e. X改进后程序实现</h4>
<div class="outline-text-4" id="text-e.-x改进后程序实现">
</div>
</div>
</div>

<div id="orgfe4d2bb" class="outline-3">
<h3 id="最小生成树问题的复杂性"><a id="orgfe4d2bb"></a>4. 最小生成树问题的复杂性</h3>
<div class="outline-text-3" id="text-最小生成树问题的复杂性">
<ul class="org-ul">
<li>最小生成树是一个非常重要的问题，人们对它做了很多进一步的研究，取得了许多成果

<ul class="org-ul">
<li>有一个证明了复杂度为 O(|E|) 的随机算法</li>
<li>有一个证明了复杂度为 O(|E|@(|E|,|V|)) 的已知最优算法，其中的 @ 是
Ackermman(m,n) 的逆函数</li>
<li>并行算法方面的工作</li>
<li>&#x2026;</li>
</ul></li>

<li>最小生成树研究还没结束。研究已经确定该问题的时间复杂度下界为
O(|E|),但还没找到这样的算法，也没找到更高的下界</li>
</ul>
</div>
</div>
</div>

<div id="org4d37199" class="outline-2">
<h2 id="六最短路径"><a id="org4d37199"></a>六、最短路径</h2>
<div class="outline-text-2" id="text-六最短路径">
<ul class="org-ul">
<li>定义：

<ul class="org-ul">
<li>在网络或带权有向图里，从顶点 v 到 v'
的一条路径上各条边的长度之和称为该路径的长度</li>
<li>从 v 到 v'
的所有路径中长度最短的路径就是最短路径，最短路径的长度为从 v 到 v'
的距离，记为 dis(v,v')</li>
</ul></li>

<li>最短路径在实际应用中特别有价值

<ul class="org-ul">
<li>运输</li>
<li>加工或者工作流程</li>
</ul></li>

<li>单源点最短路径问题要求求出从一给定顶点到其他所有顶点的最短路径</li>
</ul>
</div>

<div id="orgaf27190" class="outline-3">
<h3 id="dijkstra算法"><a id="orgaf27190"></a>1. Dijkstra算法</h3>
<div class="outline-text-3" id="text-dijkstra算法">
<ul class="org-ul">
<li>要求所有边的权不小于 0</li>
<li>假设要找从 V0 到其他顶点的最短路径，执行过程：

<ul class="org-ul">
<li>把图中顶点分为两个集合：当时已知最短路径的顶点集合 U
和尚不知道最短路径的顶点集合 V-U</li>
<li>算法逐步扩充已知最短路径的顶点集合，每次从 V-U
中找到下一个新顶点（它是当时已能确定最短路径的顶点）加入 U</li>
<li>反复这样做，直到找出 V0 到所有顶点的最短路径</li>
</ul></li>

<li>过程分析：

<ul class="org-ul">
<li>初始：在集合U中放入顶点 V0

<ul class="org-ul">
<li>V0 到 V0 的距离为 0</li>
<li>对 V-U 里的顶点，如果 (V0,V)∈E，则 V 的已知 最短路径长度为
w(V0,V)，否则令 V 的已知最短路径长为 ∞</li>
</ul></li>

<li>从 V-U 中选出当时已知最短路径长度最小的顶点 Vmin 加入 U（此时到 Vmin
的已知最短路径长度 cdis(V0,Vmin) 就是 V0 到 Vmin 的距离）</li>
<li>由于 Vmin 加入，V-U 中某些顶点的已知最短路径长度可能改变：

<ul class="org-ul">
<li>如果从 V0 经过 Vmin 到 V'
的路径长度比原已知的最短路径长度更短，这就是 V'
的新的已知最短路径长度，该路径经过 Vmin 到 V'</li>
<li>记录新的最短路径及距离，支持下面继续选择 V-U 的最近顶点</li>
</ul></li>

<li>反复选择顶点并记录新的最短路径信息，直到从 V0 可达的所有顶点都在集合
U 中为止。如果存在未加入 U 的顶点，说明图不连通</li>
</ul></li>
</ul>
</div>

<div id="org8f8f188" class="outline-4">
<h4 id="a.-程序实现-1"><a id="org8f8f188"></a>a. 程序实现</h4>
<div class="outline-text-4" id="text-a.-程序实现-1">
<pre class="example">
```python
def dijkstra(graph, v0):
    vnum = graph.vertex_num()
    assert 0 &lt;= v0 &lt; vnum
    paths = [None]*vnum
    cands = PrioQueue([(0, v0, v0)])
    count = 0
    while count &lt; vnum and not cands.is_empty():
        plen, u, vmin = cands.dequeue()
        if papths[vmin]: continue
        paths[vmin] = (u, plen)
        for v, w in graph.out_edges(vmin):
            if paths[v] is None:
                cands.enqueue((plen + w, vmin, v))
        count += 1
    return paths
```
</pre>
</div>
</div>

<div id="org457bc7c" class="outline-4">
<h4 id="b.-x复杂性分析-1"><a id="org457bc7c"></a>b. X复杂性分析</h4>
<div class="outline-text-4" id="text-b.-x复杂性分析-1">
</div>
</div>
</div>

<div id="orgfa70d09" class="outline-3">
<h3 id="各对顶点之间最短距离floyd-算法"><a id="orgfa70d09"></a>2. 各对顶点之间最短距离：Floyd 算法</h3>
<div class="outline-text-3" id="text-各对顶点之间最短距离floyd-算法">
<ul class="org-ul">
<li>可利用 Dijkstra 算法，依次把每个顶点作为起始点</li>
<li>Floyd(Floyd-Warshall)
算法可以一次直接计算出各对顶点间的所有最短路径及长度

<ul class="org-ul">
<li>该算法的基本想法来自 Warshall
的强连通子图算法(基于邻接矩阵)，实际上是求可达性(有边相邻)的传递闭包</li>
</ul></li>

<li>基本思想：

<ul class="org-ul">
<li>设图 G=(V,E) 有 n 个顶点，用邻接矩阵作为存储结构</li>
<li>如果边 (v,v')∈E，那么它就是这两顶点的路径，长度可直接得到，即
A[v][v']。但这一路径未必是从 v 到 v'
的最短路径，可能有途径其它顶点的更短路径。

<ul class="org-ul">
<li>问题就是要在 v 到 v' 的可能经过任何顶点的路径中找出最短路径</li>
</ul></li>

<li>开始：每对 v 到 v' 的途中不经过任何结点的路径长度为已知

<ul class="org-ul">
<li>有边时为边的权，无边时认为是 ∞</li>
</ul></li>

<li>k=0：对每对 v 和 v'，除已知直接路径外，从 v 到 v‘途经顶点的下标不大于 k (此时是不大于 0 )的路径可分为两段：

<ul class="org-ul">
<li>=&lt;v,v0&gt;,&lt;v0,v'&gt;=，如果没有，则认为为 ∞</li>
<li>其长度是两段路径的长度和。将其与已知最短路径比较，可确定途经顶点下标不大于
0 的最短路径</li>
</ul></li>

<li>k=1：对每对顶点 v 和 v'，从 v 到 v' 途经顶点的下标不大于 k，即不大于
1 的新路径可分为两段：

<ul class="org-ul">
<li><code>&lt;v,...,v1&gt;,&lt;v1,...,v'&gt;</code></li>
<li>这两段内部所经过的顶点下标都不大于 0，&lt;v,v0&gt;,&lt;v0,v'&gt;
已在前一步确定。</li>
<li>用新路径与已知最短路径比较，即可确定 v 到 v' 的途经顶点下标不大于
1 的最短路径</li>
</ul></li>

<li>考虑 k：每对 v 和 v'，途经顶点的下标不大于 k (已知不大于 k-1
)的最短路径可分为两段：

<ul class="org-ul">
<li><code>&lt;v,...,vk&gt;,&lt;vk,...,v'&gt;</code></li>
<li>这两段内部所经过的顶点下标都不大于 k-1，&lt; v, vk-1 &gt;，&lt; vk-1, v'&gt;`
在前一步已确定</li>
<li>用新路径与已知最短路径比较，即可确定从 v 到 v'
的途经顶点下标不大于 k 的最短路径</li>
</ul></li>

<li>如此继续，直到做完 k=n-1，也就对于每对v和v'，确定了从 v 到 v'
的所有路径中的最短路径</li>
</ul></li>
</ul>
</div>

<div id="org57a6106" class="outline-4">
<h4 id="a.-floyd-算法实现"><a id="org57a6106"></a>a. Floyd 算法实现</h4>
<div class="outline-text-4" id="text-a.-floyd-算法实现">
<ul class="org-ul">
<li>这里假定结点的下标为 0 到 n-1，实现该算法，需要迭代式地计算一系列方阵</li>
<li>为此要生成一系列 nXn 方阵 Ak(0&lt;=k&lt;=n)，其中 Ak[i][j] 表示从 vi 到 vj
的途经顶点为 v0,v1,&#x2026;,vk-1 的最短路径长度

<ul class="org-ul">
<li>A0 就是图的邻接矩阵 A，A0[i][j] 表示从 vi 到 vj
不经过任何顶点的最短路径长度</li>
<li>An[i][j] 是从 vi 到 vj 的最短路径长度</li>
</ul></li>

<li>矩阵系列 A0,A1,&#x2026;An 可递推计算 (0&lt;=i&lt;-n-1,0&lt;=j&lt;=n-1):

<ul class="org-ul">
<li>A0[i][j]=A[i][j]，直接有邻接矩阵得到</li>
<li>Ak+1[i][j]=min{Ak[i][j],Ak[i][k]+Ak[k][j]}，0&lt;=k&lt;=n-1，这时新考虑了途经顶点
vk 的路径，因此 Ak+1[i][j] 为 vi 到 vj 的途经顶点的下标不大于 k
的最短路径长度</li>
<li>An[i][j] 为 vi 到 vj 的最短路径长度</li>
</ul></li>
</ul>
</div>
</div>

<div id="orgb5fbd62" class="outline-4">
<h4 id="b.-floyd-程序实现及分析"><a id="orgb5fbd62"></a>b. Floyd 程序实现及分析</h4>
<div class="outline-text-4" id="text-b.-floyd-程序实现及分析">
</div>

<div id="org77479a3" class="outline-5">
<h5 id="路径表示"><a id="org77479a3"></a>路径表示</h5>
<div class="outline-text-5" id="text-路径表示">
<ul class="org-ul">
<li>实现算法时还需要设法做出所有路径的记录

<ul class="org-ul">
<li>下面考虑另外安排一系列 n 阶方阵 nvertexk，其中 nvertexk[v][v']
的值为在从 v 到 v' 的中间允许有顶点 v0,v1,&#x2026;,vk-1
的最短路径上，顶点 v 的后继顶点 v" 的下标</li>
<li>到最后 v" 到 v' 的最短路径也应已知，可以根据后继顶点追溯</li>
</ul></li>

<li>初始时，如果 A0[i][j]=∞ (没有边)，则令 nvertex0[i][j]=-1，否则令其为
j，表示 vj 是 vi 的后继顶点</li>
<li>在由 Ak 计算 Ak+1 时，Ak+1[i][j] 被置为 Ak[i][k]+Ak[k][j]，那么就设
nvertexk+1[i][j]=nvertexk[i][k]，即从 vi 到 vj 的路径上 vi
的后继顶点就是原来 vi 到 vk 的路径上 vi 的后继顶点

<ul class="org-ul">
<li>该轮计算完，nvertexk+1[i][j] 就是 vi 到 vj 可以途经顶点 v0,v1,&#x2026;,vk
的最短路径上 vi 的后继顶点</li>
</ul></li>

<li>计算完成后，nvertexn[i][j] 就是从 vi 到 vj 的最短路径上 vi
的后继顶点。追溯这个矩阵，可得到任何一对结点之间的最短路径</li>
</ul>
</div>
</div>

<div id="org6709412" class="outline-5">
<h5 id="距离表示"><a id="org6709412"></a>距离表示</h5>
<div class="outline-text-5" id="text-距离表示">
<ul class="org-ul">
<li>算法从 A0=A 开始。递推生成一系列的矩阵
A1,A2,&#x2026;,An，后以矩阵可能与前一矩阵不同

<ul class="org-ul">
<li>问题：是否真需要用一个新的二维矩阵表存放下一个矩阵？</li>
</ul></li>

<li>假设已经算出了 Ak 保存在矩阵 A 里，现考虑 Ak+1
的计算。Ak+1[i][j]=min{Ak[i][j],Ak[i][k]+Ak[k][j]}</li>
<li>注意：所有新的 Ak+1[i][j] 或者就是
Ak[i][j]，或者是下面的一列和一行中的元素求和计算： Ak[0][k], Ak[1][k],
&#x2026;, Ak[n-1][k] Ak[k][0], Ak[k][1], &#x2026;, Ak[k][n-1]</li>
<li>注意：如果在计算 Ak+1 过程中可能修改矩阵第 k 行或第 k
列元素，在后面去元素 [i][k] 或 [k][j] 得到的将不是 Ak
的元素，就必须保留
Ak。即如果计算中修改了后面要用的元素，就需要另外用一个新矩阵，否则就不需要，直接在矩阵里更改</li>
<li>实际上 Ak+1 计算不会修改矩阵第 k 行或第 k 列的元素，因为：
Ak+1[i][k]=min{Ak[i][k],Ak[i][k]+Ak[k][k]}
Ak+1[k][j]=min{Ak[k][j],Ak[k][k]+Ak[k][j]} 而上 Ak-1 的对角线元素上
Ak-1[m][m] 总是 0 (对所有 m)，所以 Ak+1[i][k]=Ak[i][k]
Ak+1[k][j]=Ak[k][j]</li>
<li>因此计算过程可以用同一个 A 实现所有的
Ak，矩阵的递推计算过程可以通过直接更新 A 里元素的方式实现

<ul class="org-ul">
<li>计算
Ak+1[i][j]=min{Ak[i][j],Ak[i][k]+Ak[k][j]}，其中新矩阵元素的生成用赋值
A[i][j]:=A[i][k]+A[k][j] 实现</li>
<li>计算所有顶点对之间最短路径的长度，只需要一个矩阵</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="orgd6df531" class="outline-4">
<h4 id="c.-程序实现"><a id="orgd6df531"></a>c. 程序实现</h4>
<div class="outline-text-4" id="text-c.-程序实现">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">all_shortest_paths</span><span style="color: #2aa198;">(</span>graph<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">vnum</span> = graph.vertex_num<span style="color: #2aa198;">()</span>
    <span style="color: #268bd2;">a</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span>gragh.out_edtes<span style="color: #268bd2;">(</span>i,j<span style="color: #268bd2;">)</span> <span style="color: #859900; font-weight: bold;">for</span> j <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #268bd2;">(</span>vnum<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span>
            <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #b58900;">(</span>vnum<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
    <span style="color: #268bd2;">nvertex</span> = <span style="color: #2aa198;">[</span><span style="color: #b58900;">[</span>-<span style="color: #6c71c4;">1</span> <span style="color: #859900; font-weight: bold;">if</span> a<span style="color: #268bd2;">[</span>i<span style="color: #268bd2;">][</span>j<span style="color: #268bd2;">]</span> == infinity <span style="color: #859900; font-weight: bold;">else</span> j <span style="color: #859900; font-weight: bold;">for</span> j <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #268bd2;">(</span>vnum<span style="color: #268bd2;">)</span><span style="color: #b58900;">]</span>
                <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #b58900;">(</span>vnum<span style="color: #b58900;">)</span><span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>vnum<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>vnum<span style="color: #2aa198;">)</span>:
            <span style="color: #859900; font-weight: bold;">for</span> j <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #839496; font-weight: bold;">range</span><span style="color: #2aa198;">(</span>vnum<span style="color: #2aa198;">)</span>:
                <span style="color: #268bd2;">dis</span> = a<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span>x<span style="color: #2aa198;">]</span> + a<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">][</span>j<span style="color: #2aa198;">]</span>
                <span style="color: #859900; font-weight: bold;">if</span> dis &lt; a<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span>j<span style="color: #2aa198;">]</span>:
                    a<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span>j<span style="color: #2aa198;">]</span> = dis
                    nvertex<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span>j<span style="color: #2aa198;">]</span> = nvertex<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">][</span>k<span style="color: #2aa198;">]</span>
</pre>
</div>
</div>
</div>

<div id="org130d6c7" class="outline-4">
<h4 id="d.-x复杂性分析"><a id="org130d6c7"></a>d. X复杂性分析</h4>
<div class="outline-text-4" id="text-d.-x复杂性分析">
</div>
</div>
</div>

<div id="orgb125d6c" class="outline-3">
<h3 id="最短路径算法分析"><a id="orgb125d6c"></a>3. 最短路径算法分析</h3>
<div class="outline-text-3" id="text-最短路径算法分析">
<ul class="org-ul">
<li>Dijkstra
算法基于类似于最小生成树的想法，或者说是一种"宽度优先搜索"。其中用到了类似
MST 的性质

<ul class="org-ul">
<li>它逐个找出可以确定最短路径的顶点，同时也找到了到新确定最短路径的顶点的路径</li>
<li>做完前一步后更新信息，保证记录的都是至今已知的最短路径</li>
<li>这是典型的动态规划方法(在计算中保留一些信息支持动态决策)</li>
</ul></li>

<li>Floyd 算法基于完全不同的考虑，求解所有顶点间的最短路径

<ul class="org-ul">
<li>其基本方法是为最终问题的解决逐步累积信息，根据已有的信息更新包含部分信息的解得雏形，最终得到问题的解</li>
<li>这一算法也是一个典型的动态规划方法</li>
<li>过程中求子结构(子问题)的最优解，最后得到原问题的最优解</li>
</ul></li>
</ul>
</div>
</div>
</div>

<div id="orgc6e8ed5" class="outline-2">
<h2 id="七aov网"><a id="orgc6e8ed5"></a>七、AOV网</h2>
<div class="outline-text-2" id="text-七aov网">
<ul class="org-ul">
<li>考虑有向图的一类应用‘方式'，用图中的顶点表示某种‘工程'里的活动，图中的边表示活动之间的顺序关系。这样的有向图称为顶点活动网(Activity
On Vertex network)，或称 AOV 网</li>
<li>AOV 网中的边常用语表示活动之间的制约关系

<ul class="org-ul">
<li>要解决的一个问题就是根据图中制约关系作出有关活动的安排</li>
<li>这样考虑，可以把 AOV 网络用于各种工程计划</li>
</ul></li>

<li>有一些问题，AOV 网的顶点或边还可能带有权值。可以考虑

<ul class="org-ul">
<li>最优安排问题</li>
<li>最大或最小流问题</li>
</ul></li>
</ul>
</div>

<div id="org8d8a9fc" class="outline-3">
<h3 id="拓扑排序"><a id="org8d8a9fc"></a>1. 拓扑排序</h3>
<div class="outline-text-3" id="text-拓扑排序">
<ul class="org-ul">
<li>定义：对给定的 AOV 网 N，如果 N 中的所有顶点能排成一个线性序列
S=vi1,vi2,&#x2026;,vin，满足：如果 N 中存在从顶点 vi 到 vj 的路径，那么 S
里 vi 排在 vj 之前。则 S 称为 N
的一个拓扑序列，构造拓扑序列的操作称为拓扑排序</li>
<li>AOV 网未必有拓扑序列。不难证明，一个 AOV
网存在拓扑序列，当且仅当它不包含回路(存在回路，意味着某些活动的开始要以其自身的完成作为先决条件，这种现象称为活动之间的死锁)</li>
</ul>
</div>
</div>

<div id="org5270daf" class="outline-3">
<h3 id="性质"><a id="org5270daf"></a>2. 性质</h3>
<div class="outline-text-3" id="text-性质">
<ul class="org-ul">
<li>如果一个 AOV 网有拓扑序列，其拓扑序列未必唯一</li>
<li>将 AOV 网 N 的拓扑序列反向得到的序列，都是 N 的逆网的拓扑序列</li>
<li>假设用 AOV 网表示一个工程的安排

<ul class="org-ul">
<li>网中顶点代表工程的活动，顶点之间的有向边代表活动之间的制约关系</li>
<li>如果在实际条件下各种活动只能串行进行，则那么该 AOV
网的一个拓扑序列就是整个工程得以顺利完成的一种可行方案</li>
</ul></li>

<li>任何无回路 AOV 网都可以做出拓扑序列，方法很简单：

<ul class="org-ul">
<li>从 AOV 网中选出一个入度为 0 的顶点作为序列的下一个顶点</li>
<li>从 AOV 网中删除此顶点及其所有的出边反复执行上面两步操作，直到输出了所有可输出顶点时拓扑排序结束，如果剩下入度非
0 顶点就说明该 AOV 网里存在回路，无拓扑序列</li>
</ul></li>
</ul>
</div>
</div>

<div id="orgc9cc70a" class="outline-3">
<h3 id="算法分析"><a id="orgc9cc70a"></a>3. 算法分析</h3>
<div class="outline-text-3" id="text-算法分析">
<ul class="org-ul">
<li>遍历所有顶点，统计各顶点的入边数</li>
<li>从初始顶点出发，将该顶点所有出边对应的终点的入边数减一，将入边数变为 0
的顶点加入栈</li>
<li>从栈中取出栈顶的顶点作为下一个出发顶点，重复第二步，直到栈变为空</li>
</ul>
</div>
</div>

<div id="org21e9555" class="outline-3">
<h3 id="程序实现书写图片"><a id="org21e9555"></a>4. 程序实现（书写图片）</h3>
<div class="outline-text-3" id="text-程序实现书写图片">
</div>
</div>
</div>

<div id="orgd51bf84" class="outline-2">
<h2 id="八aoe-网"><a id="orgd51bf84"></a>八、AOE 网</h2>
<div class="outline-text-2" id="text-八aoe-网">
<ul class="org-ul">
<li>AOE 网（Activity On Edge network）是另一类常用带权有向图，这是一种重要
PERT（Program Evaluation and Review Technique)模型</li>
<li>抽象看，AOE 网是一种无环的带权有向图

<ul class="org-ul">
<li>顶点表示事件，有向边表示活动</li>
<li>边上的权值通常表示活动的持续时间</li>
<li>一个顶点表示的事件也就是它的入边所表示的活动都已完成，它的出边所表示的活动可以开始的状态（事件）</li>
</ul></li>

<li>AOE 网中活动可以并行进行

<ul class="org-ul">
<li>只要一项活动的前提事件均已发生（该边的始点为终点的所有活动），这项活动就可以开始</li>
<li>因此完成整个工程的最短时间是从开始顶点到完成顶点的最长路径长度（路径上各边权值之和）</li>
</ul></li>

<li>从开始顶点到完成顶点的最长路径称为关键路径。</li>
</ul>
</div>

<div id="org9fbf25d" class="outline-3">
<h3 id="重点理解"><a id="org9fbf25d"></a>1. 重点理解</h3>
<div class="outline-text-3" id="text-重点理解">
<ul class="org-ul">
<li>一个事件 vj 的最早发生时间，必须保证 vj
的前驱事件均已发生，因此取最大值，也就是各活动以最早发生时间发生中，但却是最迟完成的，即各前驱事件的最早发生时间与活动持续时间之和的最大值</li>
<li>一个事件 vi 的最迟发生时间，必须保证不延误 vi
的所有后驱事件的发生，因此取最小值，也就是各活动以最迟发生时间发生中，但却是最先开始的，即各后驱事件的最迟发生时间减去活动持续时间之差的最小值</li>
</ul>
</div>
</div>

<div id="orga018da1" class="outline-3">
<h3 id="算法分析-1"><a id="orga018da1"></a>2. 算法分析</h3>
<div class="outline-text-3" id="text-算法分析-1">
<ul class="org-ul">
<li>生成拓扑序列</li>
<li>最早发生时间计算：初始设置每个顶点的最早发生时间为
0。按拓扑序列的顺序取出顶点，每取出一个顶点
i，对于该顶点每条出边的终点 j，若 i
的最早发生时间与该出边的权值之和大于 j 已知的最早发生时间，则更新 j
的最早发生时间为更大值</li>
<li>最迟发生时间计算：初始设置每个顶点的最迟发生时间为最后顶点的最迟发生时间。按拓扑序列的逆序取出顶点，每取出一个顶点
i，对于该顶点的每条出边的终点 j，若 j
的最迟发生时间减去该出边的权值后小于 i 已知的最迟发生时间，则更新 i
的最迟发生时间为更小值</li>
</ul>
</div>
</div>

<div id="orgffd0339" class="outline-3">
<h3 id="程序实现书写图片-1"><a id="orgffd0339"></a>3. 程序实现（书写图片）</h3>
<div class="outline-text-3" id="text-程序实现书写图片-1">
</div>
</div>
</div>
