---
layout     : post
title      : "《数据结构与算法:python语言描述》之 Stack&Queue"
categories : 数据结构与算法
tags       : 数据结构 算法 Stack Queue
excerpt    : "阅读《数据结构与算法:python语言描述》课件中 “Stack&Queue” 部分所写笔记"
---
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#一stackqueue-概述">一、stack&amp;queue 概述</a>
<ul>
<li><a href="#stackqueue-1">1. stack&amp;queue</a></li>
<li><a href="#stackqueue-的区别">2. stack&amp;queue 的区别</a></li>
<li><a href="#实现与应用">3. 实现与应用</a></li>
</ul>
</li>
<li><a href="#二stack">二、stack</a>
<ul>
<li><a href="#概念">1. 概念</a></li>
<li><a href="#基本操作">2. 基本操作</a></li>
<li><a href="#特性及实现考虑">3. 特性及实现考虑</a></li>
<li><a href="#连续表实现">4. 连续表实现</a></li>
<li><a href="#栈的应用">5. 栈的应用</a></li>
<li><a href="#应用背包问题">6. 应用:背包问题</a></li>
</ul>
</li>
<li><a href="#三队列">三、队列</a>
<ul>
<li><a href="#基本概念">1. 基本概念</a></li>
<li><a href="#基本操作-1">2. 基本操作</a></li>
<li><a href="#队列特性">3. 队列特性</a></li>
<li><a href="#队列实现">4. 队列实现</a></li>
<li><a href="#队列的应用">4. 队列的应用</a></li>
</ul>
</li>
<li><a href="#四迷宫问题">四、迷宫问题</a>
<ul>
<li><a href="#问题分析">1. 问题分析</a></li>
<li><a href="#实现方式">2. 实现方式</a></li>
<li><a href="#x3.-递归实现">X3. 递归实现</a></li>
<li><a href="#x4.-回溯实现">X4. 回溯实现</a></li>
<li><a href="#搜索性质">5. 搜索性质</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="orgf46f6b7" class="outline-2">
<h2 id="一stackqueue-概述"><a id="orgf46f6b7"></a>一、stack&amp;queue 概述</h2>
<div class="outline-text-2" id="text-一stackqueue-概述">
</div>

<div id="org89dec23" class="outline-3">
<h3 id="stackqueue-1"><a id="org89dec23"></a>1. stack&amp;queue</h3>
<div class="outline-text-3" id="text-stackqueue-1">
<ul class="org-ul">
<li>保存数据元素的容器，元素存入，查看元素，弹出元素（取得元素的同时将其从容器中删除）</li>
<li>用于在计算过程中临时性地保存元素</li>
<li>常用于生成数据和使用之间的缓冲，称为缓冲存储或缓存</li>
<li>stack 和queue
存入操作只需保证元素存入和将来取出的顺序，不需记录或保证存入的元素与容器已有元素之间的任何关系</li>
<li>任何时候访问或删除的元素都默认地唯一确定。只有新的存入或弹出操作可能改变下次的默认元素</li>
</ul>
</div>
</div>

<div id="org1a1c62a" class="outline-3">
<h3 id="stackqueue-的区别"><a id="org1a1c62a"></a>2. stack&amp;queue 的区别</h3>
<div class="outline-text-3" id="text-stackqueue-的区别">
<ul class="org-ul">
<li><code>stack</code> 是保证缓存元素的后进先出 (LIFO) 的结构</li>
<li>队列是保证缓存元素的先进先出 (FIFO) 结构</li>
</ul>
</div>
</div>

<div id="org1263314" class="outline-3">
<h3 id="实现与应用"><a id="org1263314"></a>3. 实现与应用</h3>
<div class="outline-text-3" id="text-实现与应用">
<ul class="org-ul">
<li>stack&amp;queue 的特点完全是抽象的逻辑，对于实现没有约束</li>
<li>可以利用元素的排列顺序表示他们的先来后到，即`用线性表作为它们的实现结构</li>
<li>使用环境

<ol class="org-ol">
<li>计算过程分为一些顺序进行的步骤</li>
<li>执行中会不断产生一些后面可能需要的中间数据</li>
<li>数据不能立即使用，但必须保存以备后面使用</li>
<li>需要保存的数据的项数不能事先确定</li>
</ol></li>
</ul>
</div>
</div>
</div>

<div id="orgd17596c" class="outline-2">
<h2 id="二stack"><a id="orgd17596c"></a>二、stack</h2>
<div class="outline-text-2" id="text-二stack">
</div>

<div id="orgb442bb3" class="outline-3">
<h3 id="概念"><a id="orgb442bb3"></a>1. 概念</h3>
<div class="outline-text-3" id="text-概念">
<ul class="org-ul">
<li>栈，有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素。
<code>没有位置概念</code></li>
<li><code>保证任何时候可以访问、删除的元素都是此前最后存入的那个元素。确定了一种默认的访问顺序</code></li>
</ul>
</div>
</div>

<div id="org33695c9" class="outline-3">
<h3 id="基本操作"><a id="org33695c9"></a>2. 基本操作</h3>
<div class="outline-text-3" id="text-基本操作">
<ul class="org-ul">
<li>创建空栈</li>
<li>判断栈是否为空(可能还需判断满)，is\_empty()</li>
<li>向栈中插入(通常称推入/压入)一个元素，push(&#x2026;)</li>
<li>从栈中删除(弹出)一个元素，空栈弹出报错，pop()</li>
<li>取当前元素的值(并不删除)，top()</li>
</ul>
</div>
</div>

<div id="orgf968bcc" class="outline-3">
<h3 id="特性及实现考虑"><a id="orgf968bcc"></a>3. 特性及实现考虑</h3>
<div class="outline-text-3" id="text-特性及实现考虑">
<ul class="org-ul">
<li>可以实现为只在一端插入和删除的表

<ul class="org-ul">
<li>因此有人把栈称为后进先出表（LIFO)</li>
<li>进行插入或删除操作的一端称为栈顶，另一端称为栈底</li>
</ul></li>

<li>用线性表实现时，考虑效率最高的那一端作为栈顶

<ul class="org-ul">
<li>采用连续表，在后端插入删除都是 O(1) 操作</li>
<li>采用链接表，前端插入删除都是 O(1) 操作</li>
</ul></li>

<li><p>
实现前，定义一个异常类( python 内部异常是一组类，都是 Exception
的子类，可以继承已有异常类来定义自己的异常类）
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #586e75;"># </span><span style="color: #586e75;">&#26632;&#19979;&#28322;&#65288;&#31354;&#26632;&#35775;&#38382;&#65289;</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">StackUnderflow</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">ValueError</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">pass</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="orga98dcb6" class="outline-3">
<h3 id="连续表实现"><a id="orga98dcb6"></a>4. 连续表实现</h3>
<div class="outline-text-3" id="text-连续表实现">
<ul class="org-ul">
<li>问题

<ul class="org-ul">
<li>简单连续表，可能出现栈满</li>
<li>动态连续表，置换策略问题以及分期付款式的 O(1) 复杂性</li>
</ul></li>

<li>python list 的操作特性使得其可以作为栈使用

<ul class="org-ul">
<li>建立空栈，对应创建一个 []，判断空栈对应判断空表</li>
<li>由于 list 采用动态连续表技术，因此不会出现栈满</li>
<li>压入元素应在表尾端进行，对应 append()</li>
<li>弹出操作也应在尾端，对应 pop()</li>
<li>由于是动态连线表，压入操作具有分期付款式的 O(1) 复杂性，其它操作都是
O(1) 操作</li>
</ul></li>
</ul>
</div>

<div id="orgcdf02d9" class="outline-4">
<h4 id="a.-程序实现利用-list"><a id="orgcdf02d9"></a>a. 程序实现，利用 list</h4>
<div class="outline-text-4" id="text-a.-程序实现利用-list">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Sstack</span><span style="color: #2aa198;">()</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.elems = <span style="color: #2aa198;">[]</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">isEmpty</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems == <span style="color: #2aa198;">[]</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">top</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.elems == <span style="color: #2aa198;">[]</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> StackUnderflow
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">[</span><span style="color: #839496; font-weight: bold;">len</span><span style="color: #b58900;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #b58900;">)</span>-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">pop</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.elems == <span style="color: #2aa198;">[]</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> StackUnderflow
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.elems.pop<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">push</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.elems.append<span style="color: #2aa198;">(</span>e<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>

<div id="org2782b74" class="outline-4">
<h4 id="b.-程序实现用链接技术"><a id="org2782b74"></a>b. 程序实现，用链接技术</h4>
<div class="outline-text-4" id="text-b.-程序实现用链接技术">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">LStack</span><span style="color: #2aa198;">()</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.top = <span style="color: #268bd2; font-weight: bold;">None</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">isEmpty</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.top <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">top</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.top <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> StackUnderflow
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #859900; font-weight: bold;">self</span>.top.elem
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">pop</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">self</span>.top <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #268bd2; font-weight: bold;">None</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> StackUnderflow
        <span style="color: #268bd2;">e</span> = <span style="color: #859900; font-weight: bold;">self</span>.top.elem
        <span style="color: #859900; font-weight: bold;">self</span>.top = <span style="color: #859900; font-weight: bold;">self</span>.top.<span style="color: #839496; font-weight: bold;">next</span>
        <span style="color: #859900; font-weight: bold;">return</span> e
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">push</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>, e<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">self</span>.top = LNode<span style="color: #2aa198;">(</span>e, <span style="color: #859900; font-weight: bold;">self</span>.top<span style="color: #2aa198;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="orgfeec992" class="outline-3">
<h3 id="栈的应用"><a id="orgfeec992"></a>5. 栈的应用</h3>
<div class="outline-text-3" id="text-栈的应用">
<ul class="org-ul">
<li>栈是算法和程序里最常用的辅助结构，基本用途基于两个方面：

<ul class="org-ul">
<li>作为算法或程序里的辅助存储结构</li>
<li>利用后进先出的特点，可以得到特定的存储和取用顺序</li>
</ul></li>

<li>最简单的应用实例，可以用于颠倒一组元素的顺序

<ul class="org-ul">
<li>将一组元素全部存入后取出，得到反序的序列</li>
<li>通过不同的存入取出操作序列，可以得到不同的元素序列</li>
</ul></li>
</ul>
</div>

<div id="org1ecda9a" class="outline-4">
<h4 id="a.-括号配对问题"><a id="org1ecda9a"></a>a. 括号配对问题</h4>
<div class="outline-text-4" id="text-a.-括号配对问题">
<p>
括号有圆括号、方括号、花括号，每种还分开括号与闭括号，括号里面的片段可能相互嵌套
</p>

<ul class="org-ul">
<li>配对原则：

<ul class="org-ul">
<li>遇到的闭括号应匹配与其最近尚未匹配的开括号</li>
<li>由于多种或多次的可能嵌套，因此需要保存开括号</li>
<li>由于嵌套，需要逐对匹配，后面的闭括号应与更前的匹配</li>
<li>可以删除匹配的括号，为后面的匹配做好准备</li>
</ul></li>

<li>问题描述：

<ul class="org-ul">
<li>顺序检查正文里的每个字符</li>
<li>遇到开括号时将其压入到一个栈，其它字符跳过</li>
<li>遇到闭括号时弹出栈顶元素与之匹配，若匹配则继续，若不匹配则检查以失败结束</li>
</ul></li>

<li><p>
程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">check_pares</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">pares</span> = <span style="color: #2aa198;">"()[]{}"</span>
    <span style="color: #268bd2;">open_pares</span> = <span style="color: #2aa198;">"([{"</span>
    <span style="color: #268bd2;">opposite</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">")"</span>:<span style="color: #2aa198;">"("</span>, <span style="color: #2aa198;">"]"</span>:<span style="color: #2aa198;">"["</span>, <span style="color: #2aa198;">"}"</span>:<span style="color: #2aa198;">"{"</span><span style="color: #2aa198;">}</span>
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">paretheses</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>:...

    <span style="color: #268bd2;">st</span> = SStack<span style="color: #2aa198;">()</span>

    <span style="color: #859900; font-weight: bold;">for</span> pr,i <span style="color: #859900; font-weight: bold;">in</span> parethese<span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> pr <span style="color: #859900; font-weight: bold;">in</span> open_pares:
            st.push<span style="color: #2aa198;">(</span>pr<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">elif</span> st.pop<span style="color: #2aa198;">()</span> != opposite<span style="color: #2aa198;">[</span>pr<span style="color: #2aa198;">]</span>:
            <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Unmatching is found at"</span>, i, <span style="color: #2aa198;">"for"</span>, pr<span style="color: #2aa198;">)</span>
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">False</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"All paretheses are correctly matched."</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">True</span>
</pre>
</div></li>

<li><p>
括号生成器定义为局部函数
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">paretheses</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">text_len</span> = <span style="color: #6c71c4;">0</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>text<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2; font-weight: bold;">True</span>:
        <span style="color: #859900; font-weight: bold;">while</span> i &lt; text_len <span style="color: #859900; font-weight: bold;">and</span> text<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #859900; font-weight: bold;">in</span> pares:
            <span style="color: #268bd2;">i</span> += <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">if</span> i &gt;= text_len:
            <span style="color: #859900; font-weight: bold;">return</span>
        <span style="color: #859900; font-weight: bold;">yield</span> text<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>, i
        <span style="color: #268bd2;">i</span> += <span style="color: #6c71c4;">1</span>
</pre>
</div></li>
</ul>
</div>

<div id="orgf133a24" class="outline-5">
<h5 id="x检查python或c程序里的括号"><a id="orgf133a24"></a>X检查python或c程序里的括号</h5>
<div class="outline-text-5" id="text-x检查python或c程序里的括号">
<ul class="org-ul">
<li>需要跳过注释和字符串</li>
</ul>
</div>
</div>
</div>

<div id="org19f6f87" class="outline-4">
<h4 id="b.-表达式的表示计算和变换"><a id="org19f6f87"></a>b. 表达式的表示、计算和变换</h4>
<div class="outline-text-4" id="text-b.-表达式的表示计算和变换">
<ul class="org-ul">
<li>表达式种类：

<ul class="org-ul">
<li>中缀表达式：运算符在运算对象中间，需要括号还有优先级</li>
<li>前缀表达式：运算符在运算对象前面</li>
<li>后缀表达式：运算符在运算对象后面</li>
</ul></li>

<li>后缀表达式分析：

<ul class="org-ul">
<li>要处理的是算术表达式</li>
<li>运算对象是浮点数形式表示的数</li>
<li>运算符只有 "+"、"-"、“*”、"/"，都是二元运算符</li>
</ul></li>

<li>计算过程分析：

<ul class="org-ul">
<li>遇到运算对象需要记录以备后面使用</li>
<li>遇到运算符，取得前面遇到的几个运算对象或已做运算得到的结果，实施计算并记录结果</li>
<li>通过以上分析，显然应该使用栈作为缓存结构</li>
</ul></li>

<li><p>
后缀表达式求值程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">suf_exp_evaluator</span><span style="color: #2aa198;">(</span>exp<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">operator</span> = <span style="color: #2aa198;">"+-*/"</span>
    <span style="color: #268bd2;">st</span> = ESStack<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> exp:
        <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #859900; font-weight: bold;">not</span> x <span style="color: #859900; font-weight: bold;">in</span> operator:
            st.push<span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">if</span> st.depth<span style="color: #2aa198;">()</span> &lt; <span style="color: #6c71c4;">2</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> SynaxError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Short of operand(s)."</span><span style="color: #2aa198;">)</span>
        <span style="color: #268bd2;">b</span> = st.pop<span style="color: #2aa198;">()</span>
        <span style="color: #268bd2;">a</span> = st.pop<span style="color: #2aa198;">()</span>
        <span style="color: #859900; font-weight: bold;">if</span> x == <span style="color: #2aa198;">"+"</span>:
            <span style="color: #268bd2;">c</span> = a + b
        <span style="color: #859900; font-weight: bold;">elif</span> x == <span style="color: #2aa198;">"-"</span>:
            <span style="color: #268bd2;">c</span> = a - b
        <span style="color: #859900; font-weight: bold;">elif</span> x == <span style="color: #2aa198;">"*"</span>:
            <span style="color: #268bd2;">c</span> = a * b
        <span style="color: #859900; font-weight: bold;">elif</span> x == <span style="color: #2aa198;">"/"</span>:
            <span style="color: #859900; font-weight: bold;">if</span> b == <span style="color: #6c71c4;">0</span>:
                <span style="color: #859900; font-weight: bold;">raise</span> <span style="color: #b58900;">ZeroDivisionError</span>
            <span style="color: #268bd2;">c</span> = a / b
        <span style="color: #859900; font-weight: bold;">else</span>: <span style="color: #859900; font-weight: bold;">pass</span>
        st.push<span style="color: #2aa198;">(</span>c<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">if</span> st.depth<span style="color: #2aa198;">()</span> == <span style="color: #6c71c4;">1</span>:
        <span style="color: #859900; font-weight: bold;">return</span> st.pop<span style="color: #2aa198;">()</span>
    <span style="color: #859900; font-weight: bold;">raise</span> SynaxError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Extra operand(s)."</span><span style="color: #2aa198;">)</span>

<span style="color: #586e75;"># </span><span style="color: #586e75;">&#32473;&#26632;&#22686;&#21152;&#19968;&#20010;&#26816;&#26597;&#26632;&#28145;&#24230;&#30340;&#26041;&#27861;</span>
<span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ESStack</span><span style="color: #2aa198;">(</span>SStack<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">depth</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span><span style="color: #859900; font-weight: bold;">self</span>.elems<span style="color: #2aa198;">)</span>

<span style="color: #586e75;"># </span><span style="color: #586e75;">&#23558;&#34920;&#36798;&#24335;&#36716;&#21270;&#20026;&#39033;&#30340;&#34920;&#65292;line.split()</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">suffix_exp_evaluator</span><span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">return</span> suf_exp_evaluator<span style="color: #2aa198;">(</span>line.split<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>

<span style="color: #586e75;"># </span><span style="color: #586e75;">&#23450;&#20041;&#19968;&#20010;&#20132;&#20114;&#24335;&#30340;&#39537;&#21160;&#20989;&#25968;</span>
<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">stuffix_exp_calculator</span><span style="color: #2aa198;">()</span>:
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #268bd2; font-weight: bold;">True</span>:
        <span style="color: #859900; font-weight: bold;">try</span>:
            <span style="color: #268bd2;">line</span> = <span style="color: #839496; font-weight: bold;">input</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Stuffix Expression: "</span><span style="color: #2aa198;">)</span>
            <span style="color: #859900; font-weight: bold;">if</span> line == <span style="color: #2aa198;">"end"</span>:
                <span style="color: #859900; font-weight: bold;">return</span>
            <span style="color: #268bd2;">res</span> = suffix_exp_evaluator<span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>
            <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>res<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">except</span> <span style="color: #b58900;">Exception</span> <span style="color: #859900; font-weight: bold;">as</span> ex:
            <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Error:"</span>, <span style="color: #839496; font-weight: bold;">type</span><span style="color: #b58900;">(</span>ex<span style="color: #b58900;">)</span>, ex.args<span style="color: #2aa198;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="org848c044" class="outline-4">
<h4 id="c.-中缀表达式转换为后缀表达式"><a id="org848c044"></a>c. 中缀表达式转换为后缀表达式</h4>
<div class="outline-text-4" id="text-c.-中缀表达式转换为后缀表达式">
<ul class="org-ul">
<li>若本次运算符的优先级不高于上次，则先输出上次的运算符，然后记录本次运算符。</li>
<li>遇到左括号时记录，遇到右括号时，反向输出所记录的运算符，因为括号里的运算优先于括号外，然后由于记录的运算符顺序肯定是从低到高，因此反向输出（即后进先出）</li>
<li>最后可能剩下一些记录的运算符，也应反向输出</li>
<li><p>
中缀转换为后缀程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #268bd2;">priority</span> = <span style="color: #2aa198;">{</span><span style="color: #2aa198;">"("</span>:<span style="color: #6c71c4;">1</span>, <span style="color: #2aa198;">"+"</span>:<span style="color: #6c71c4;">3</span>, <span style="color: #2aa198;">"-"</span>:<span style="color: #6c71c4;">3</span>. <span style="color: #2aa198;">"*"</span>:<span style="color: #6c71c4;">5</span>, <span style="color: #2aa198;">"/"</span>:<span style="color: #6c71c4;">5</span><span style="color: #2aa198;">}</span>
<span style="color: #268bd2;">infix_operators</span> = <span style="color: #2aa198;">"+-*/()"</span>

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">trans_infix_stuffix</span><span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">st</span> = SStack<span style="color: #2aa198;">()</span>; <span style="color: #268bd2;">llen</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>; <span style="color: #268bd2;">exp</span> = <span style="color: #2aa198;">[]</span>
    <span style="color: #859900; font-weight: bold;">for</span> x <span style="color: #859900; font-weight: bold;">in</span> tokens<span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">if</span> x <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #859900; font-weight: bold;">in</span> infix_operators:
            exp.append<span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">elif</span> st.isEmpty <span style="color: #859900; font-weight: bold;">or</span> x == <span style="color: #2aa198;">"("</span>:
            st.push<span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">elif</span> x == <span style="color: #2aa198;">")"</span>:
            <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> st.isEmpty <span style="color: #859900; font-weight: bold;">and</span> st.top<span style="color: #2aa198;">()</span> != <span style="color: #2aa198;">"("</span>:
                exp.append<span style="color: #2aa198;">(</span>st.top<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>
            <span style="color: #859900; font-weight: bold;">if</span> st.isEmpty<span style="color: #2aa198;">()</span>:
                <span style="color: #859900; font-weight: bold;">raise</span> SynaxError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Missing \'(\'."</span><span style="color: #2aa198;">)</span>
            st.pop<span style="color: #2aa198;">()</span>
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #859900; font-weight: bold;">not</span> st.isEmpty <span style="color: #859900; font-weight: bold;">and</span> priority<span style="color: #2aa198;">[</span>x<span style="color: #2aa198;">]</span> &lt; priority<span style="color: #2aa198;">[</span>st.top<span style="color: #b58900;">()</span><span style="color: #2aa198;">]</span>:
                exp.append<span style="color: #2aa198;">[</span>st.pop<span style="color: #b58900;">()</span><span style="color: #2aa198;">]</span>
            st.push<span style="color: #2aa198;">(</span>x<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #859900; font-weight: bold;">not</span> st.isEmpty<span style="color: #2aa198;">()</span>:
        <span style="color: #859900; font-weight: bold;">if</span> st.top<span style="color: #2aa198;">()</span> == <span style="color: #2aa198;">"("</span>:
            <span style="color: #859900; font-weight: bold;">raise</span> SynaxError<span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Extra \'(\' in expressing."</span><span style="color: #2aa198;">)</span>
        exp.append<span style="color: #2aa198;">(</span>st.pop<span style="color: #b58900;">()</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">return</span> exp

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">tokens</span><span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>: <span style="color: #586e75;"># </span><span style="color: #586e75;">&#34920;&#36798;&#24335;&#29983;&#25104;</span>
    <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">llen</span> = <span style="color: #6c71c4;">0</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>line<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">while</span> i &lt; llen:
        <span style="color: #859900; font-weight: bold;">while</span> line<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>.isspace<span style="color: #2aa198;">()</span>:
            <span style="color: #268bd2;">i</span> += <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">if</span> i &gt;= llen: <span style="color: #859900; font-weight: bold;">break</span>
        <span style="color: #859900; font-weight: bold;">if</span> line<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> <span style="color: #859900; font-weight: bold;">in</span> infix_operators:
            <span style="color: #859900; font-weight: bold;">yield</span> line<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>
            <span style="color: #268bd2;">i</span> += <span style="color: #6c71c4;">1</span>
            <span style="color: #859900; font-weight: bold;">continue</span>
        <span style="color: #268bd2;">j</span> = i+<span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">while</span> <span style="color: #2aa198;">(</span>j &lt; llen <span style="color: #859900; font-weight: bold;">and</span> <span style="color: #859900; font-weight: bold;">not</span> line<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span>.isspace<span style="color: #b58900;">()</span> <span style="color: #859900; font-weight: bold;">and</span>
                line<span style="color: #b58900;">[</span>j<span style="color: #b58900;">]</span> <span style="color: #859900; font-weight: bold;">not</span> <span style="color: #859900; font-weight: bold;">in</span> infix_operators<span style="color: #2aa198;">)</span>:
            <span style="color: #859900; font-weight: bold;">if</span> <span style="color: #2aa198;">(</span><span style="color: #b58900;">(</span>line<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> == <span style="color: #2aa198;">'e'</span> <span style="color: #859900; font-weight: bold;">or</span> line<span style="color: #268bd2;">[</span>j<span style="color: #268bd2;">]</span> == <span style="color: #2aa198;">'E'</span><span style="color: #b58900;">)</span>
                <span style="color: #859900; font-weight: bold;">and</span> j+<span style="color: #6c71c4;">1</span> &lt; llen <span style="color: #859900; font-weight: bold;">and</span> lin<span style="color: #b58900;">[</span>j+<span style="color: #6c71c4;">1</span><span style="color: #b58900;">]</span> == <span style="color: #2aa198;">'-'</span><span style="color: #2aa198;">)</span>:
                <span style="color: #268bd2;">j</span> += <span style="color: #6c71c4;">1</span>
            <span style="color: #268bd2;">j</span> += <span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">yield</span> line<span style="color: #2aa198;">[</span>i:j<span style="color: #2aa198;">]</span>
        <span style="color: #268bd2;">i</span> = j

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">test_trans_infix_suffix</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>: <span style="color: #586e75;"># </span><span style="color: #586e75;">&#27979;&#35797;&#36741;&#21161;&#20989;&#25968;</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>s<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span>trans_infix_suffix<span style="color: #b58900;">(</span>s<span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Value:"</span>, suf_exp_evaluator<span style="color: #b58900;">(</span>trans_infix_suffix<span style="color: #268bd2;">(</span>s<span style="color: #268bd2;">)</span><span style="color: #b58900;">)</span><span style="color: #2aa198;">)</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="org0215657" class="outline-4">
<h4 id="d.-栈与递归"><a id="org0215657"></a>d. 栈与递归</h4>
<div class="outline-text-4" id="text-d.-栈与递归">
<ul class="org-ul">
<li>如果一个定义或结构（如 python
函数，数据结构）中的某个或几个部分具有与整体同样的结构，则称其为递归定义或递归结构</li>
<li><code>递归定义中的递归部分必须比整体简单，这样最后才能有终结点</code>
（称为递归定义的出口）；
<code>递归结构中也必须存在由非递归的基本结构构成的部分</code>
。否则就是无限递归。</li>
<li>例如：

<ul class="org-ul">
<li>递归定义的 python 函数（通过调用自身完成）</li>
<li>结点链构成的单链表（非空时，去掉一个结点还是同样结构）</li>
<li>简单表达式：

<ul class="org-ul">
<li>常数、变量是表达式</li>
<li>若 \(e_1\) ， \(e_2\) 是表达式，op 是运算符，则 \(e_1\) op \(e_2\) ，op
\(e_2\) ， ( \(e_1\) ) 也是表达式</li>
</ul></li>

<li><p>
阶乘函数 n！：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">fact</span><span style="color: #2aa198;">(</span>n<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> n == <span style="color: #6c71c4;">0</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #6c71c4;">1</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #859900; font-weight: bold;">return</span> n * fact<span style="color: #2aa198;">(</span>n - <span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>
</pre>
</div></li>
</ul></li>
</ul>
</div>
</div>

<div id="org22c290a" class="outline-4">
<h4 id="e.-递归算法与函数调用"><a id="org22c290a"></a>e. 递归算法与函数调用</h4>
<div class="outline-text-4" id="text-e.-递归算法与函数调用">
<ul class="org-ul">
<li>问题：在递归函数执行中将会递归调用自己，而且还可能继续这样递归调用。这种过程在计算机上如何实现？</li>
<li>考虑上述的递归定义函数 fact

<ul class="org-ul">
<li>要得到 fact(6) 的结果，需知道 fact(5)</li>
<li>计算 fact(6) 时 n 取值 6，计算 fact(5) 是 n 取值 5，如此循环</li>
<li>而计算出 fact(5) 的值还要乘以 6 得到 fact(6)
的值，说明递归调用时要记录n的值</li>
<li>需要记录的数据量与递归次数成线性关系，不能定义几个整型变量保存数据</li>
</ul></li>

<li>支持递归的实现需要一个栈（运行栈），实现递归函数时

<ul class="org-ul">
<li>每个具体的递归调用都有一些局部信息需要保存，语言的实现在运行栈上为函数的这次调用建立一个帧，其中保存相关信息</li>
<li>函数执行总以栈顶帧作为当前帧，所有局部变量都在这里有体现</li>
<li>进入下次递归调用时，将为它建立一个新帧</li>
<li>从递归调用返回时，上层取得函数调用的结果，并弹出已经结束的调用对应的帧，然后回到上一层执行时的状态</li>
</ul></li>

<li><p>
实现过程分析：
</p>

<pre class="example">
def fact(n)
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
</pre></li>
</ul>
</div>

<div id="orgb82b959" class="outline-5">
<h5 id="函数调用"><a id="orgb82b959"></a>函数调用</h5>
<div class="outline-text-5" id="text-函数调用">
<ul class="org-ul">
<li>程序里函数调用是按先 <code>后调用先返回</code> 的规则进行</li>
<li>支持函数调用的进行，语言实现需要做一些内部动作

<ul class="org-ul">
<li>在进入新函数前保存一些信息，退出函数时恢复调用前状态并继续</li>
</ul></li>

<li>上述两部分动作分别称为函数调用的前序和后序动作</li>
<li>调用的前序动作：

<ul class="org-ul">
<li>为被调用函数的局部变量分配存储区</li>
<li>将所有实参和返回地址存入函数帧</li>
<li>将控制转到被调用函数入口</li>
</ul></li>

<li>调用的后序动作：

<ul class="org-ul">
<li>将被调用函数的计算结果存入指定位置</li>
<li>释放被调用函数的存储区</li>
<li>按以前保存的返回地址将控制转回调用函数</li>
</ul></li>
</ul>


<div class="figure">
<p><img src="https://ooo.0o0.ooo/2016/05/24/5743e7b3d571e.jpg" alt="5743e7b3d571e.jpg" />
</p>
<p><span class="figure-number">&#22270;1&nbsp; </span>函数栈.jpg</p>
</div>

<ul class="org-ul">
<li>递归定义的函数每次递归函数调用，都将自动执行上述动作，若要转为非递归，需要自己做这些事情，
<code>用一个栈保存使用的中间信息</code></li>
<li><p>
考虑阶乘函数的非递归形式：
</p>

<pre class="example">
def norec_fact(n):
    res = 1
    st = SStack()
    while n &gt; 0:
        st.push(n)
        n -= 1
    while not st.isEmpty():
        res *= st.pop()
    return res
</pre></li>
</ul>
</div>
</div>

<div id="org4c06aab" class="outline-5">
<h5 id="递归与非递归"><a id="org4c06aab"></a>递归与非递归</h5>
<div class="outline-text-5" id="text-递归与非递归">
<ul class="org-ul">
<li>可以证明：
<code>任何递归定义的函数，都可以通过引入一个栈保存中间结果，翻译为一个非递归过程。任何一个包含循环的程序都可翻译为一个不包含循环的递归程序</code></li>
</ul>
</div>
</div>
</div>
</div>

<div id="org8a5e1e7" class="outline-3">
<h3 id="应用背包问题"><a id="org8a5e1e7"></a>6. 应用:背包问题</h3>
<div class="outline-text-3" id="text-应用背包问题">
<ul class="org-ul">
<li>假设 knap(W, n) 表示 n 件物品相对于 W 的背包问题，s 表示 n
件物品的集合</li>
<li>重点： <code>对每一种重量的物体要么选择要么不选择</code>

<ul class="org-ul">
<li>若选择 \(W_n\) ，则 \(knap(W-W_n, n-1)\) 的解就是 knap(W, n) 的解</li>
<li>若不选择 \(W_n\) ，则 knap(W, n-1) 的解就是 knap(W, n) 的解</li>
</ul></li>

<li>情况分析：

<ul class="org-ul">
<li>当 W = 0；True</li>
<li>当 W &lt; 0；False</li>
<li>当 W &gt; 0, n &lt; 1；False</li>
<li>当 s &gt; 0, n &gt;= 1； knap(W, n-1) 或 \(knap(W-W_n, n-1)\)</li>
</ul></li>

<li><p>
程序实现：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">knap_rec</span><span style="color: #2aa198;">(</span>weight, wlist, n<span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">if</span> weight == <span style="color: #6c71c4;">0</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">True</span>
    <span style="color: #859900; font-weight: bold;">elif</span> weight &lt; <span style="color: #6c71c4;">0</span>:
        <span style="color: #859900; font-weight: bold;">return</span> Flase
    <span style="color: #859900; font-weight: bold;">elif</span> weight &gt; <span style="color: #6c71c4;">0</span> <span style="color: #859900; font-weight: bold;">and</span> n &lt; <span style="color: #6c71c4;">1</span>:
        <span style="color: #859900; font-weight: bold;">return</span> Flase
    <span style="color: #859900; font-weight: bold;">elif</span> knap_rec<span style="color: #2aa198;">(</span>weight-wlist<span style="color: #b58900;">[</span>n-<span style="color: #6c71c4;">1</span><span style="color: #b58900;">]</span>, wlist, n-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">print</span><span style="color: #2aa198;">(</span><span style="color: #2aa198;">"Item"</span> + <span style="color: #839496; font-weight: bold;">str</span><span style="color: #b58900;">(</span>n<span style="color: #b58900;">)</span> + <span style="color: #2aa198;">":"</span>,wlist<span style="color: #b58900;">[</span>n-<span style="color: #6c71c4;">1</span><span style="color: #b58900;">]</span><span style="color: #2aa198;">)</span>
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">True</span>
    <span style="color: #859900; font-weight: bold;">elif</span> knap_rec<span style="color: #2aa198;">(</span>weight, wlist, n-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">)</span>:
        <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">True</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #859900; font-weight: bold;">return</span> Flase
</pre>
</div></li>
</ul>
</div>
</div>
</div>

<div id="orgd159132" class="outline-2">
<h2 id="三队列"><a id="orgd159132"></a>三、队列</h2>
<div class="outline-text-2" id="text-三队列">
</div>

<div id="org8495392" class="outline-3">
<h3 id="基本概念"><a id="org8495392"></a>1. 基本概念</h3>
<div class="outline-text-3" id="text-基本概念">
<ul class="org-ul">
<li>可存入、访问、删除数据元素</li>
<li><code>保证在任何时刻可访问、删除的元素都是在此之前最早存入队列而至今未删除的那个元素</code></li>
<li><code>确定了一种由存储顺序决定的访问顺序</code></li>
</ul>
</div>
</div>

<div id="org1f8191f" class="outline-3">
<h3 id="基本操作-1"><a id="org1f8191f"></a>2. 基本操作</h3>
<div class="outline-text-3" id="text-基本操作-1">
<ul class="org-ul">
<li>创建空队列</li>
<li>判断队列是否为空（判断满）</li>
<li>将元素放入队列，入列（enqueue）</li>
<li>从队列删除，出列（dequeue）</li>
<li>取当前元素的值（最老的，并不删除</li>
</ul>
</div>
</div>

<div id="orge05768c" class="outline-3">
<h3 id="队列特性"><a id="orge05768c"></a>3. 队列特性</h3>
<div class="outline-text-3" id="text-队列特性">
<ul class="org-ul">
<li>保证访问或删除元素的 "FIFO" 原则</li>
<li><code>与"时间"有关的结构</code></li>
<li><code>只在一端插入另一端访问或删除的表</code></li>
<li>出队操作的一端称为队头</li>
<li>入队操作的一端称为队尾</li>
</ul>
</div>
</div>

<div id="org9f34431" class="outline-3">
<h3 id="队列实现"><a id="org9f34431"></a>4. 队列实现</h3>
<div class="outline-text-3" id="text-队列实现">
<ul class="org-ul">
<li>用线性表实现，因为要在两端操作，比栈麻烦一些</li>
<li>用链接表的话， <code>应该考虑带尾指针的链接表</code></li>
<li>环形队列</li>
</ul>
</div>

<div id="orgad90f38" class="outline-4">
<h4 id="a.-list-实现"><a id="orgad90f38"></a>a. list 实现</h4>
<div class="outline-text-4" id="text-a.-list-实现">
<ul class="org-ul">
<li>基于 python 的 list 实现顺序表示的队列

<ul class="org-ul">
<li>最简单的实现方法得到 O(1) 的 enqueue 和 O(n) 的 dequeue</li>
</ul></li>

<li>由于 python 的 list
不提供检查元素存储区容量的机制，很难利用其自动扩充元素区的机制，但可以自己做</li>
<li><p>
首先，队列可能由于空而无法 dequeue，定义一个异常
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">QueueUnderflow</span><span style="color: #2aa198;">(</span><span style="color: #b58900;">ValueError</span><span style="color: #2aa198;">)</span>:
    <span style="color: #859900; font-weight: bold;">pass</span>
<span style="color: #586e75;"># </span><span style="color: #586e75;">&#32487;&#25215;&#31995;&#32479;&#25552;&#20379;&#30340;&#24322;&#24120;</span>
</pre>
</div></li>

<li>SQueue 类的基本考虑：

<ul class="org-ul">
<li>用 SQueue 对象的一个 list 类型的成分 elems 存放队里元素</li>
<li>用 head 和 elnum 记录首元素位置的下标和表中元素个数</li>
<li>为能判断存储区是否满以便换一个表，需要记录表长度，用 len</li>
</ul></li>
</ul>
</div>
</div>

<div id="org08c90d9" class="outline-4">
<h4 id="xb.-数据不变式"><a id="org08c90d9"></a>Xb. 数据不变式</h4>
<div class="outline-text-4" id="text-xb.-数据不变式">
<ul class="org-ul">
<li>数据结构的之间的协调统一性，待补充</li>
</ul>
</div>
</div>
</div>

<div id="org7c1d7c7" class="outline-3">
<h3 id="队列的应用"><a id="org7c1d7c7"></a>4. 队列的应用</h3>
<div class="outline-text-3" id="text-队列的应用">
</div>

<div id="org728f571" class="outline-4">
<h4 id="a.-离散事件模拟"><a id="org728f571"></a>a. 离散事件模拟</h4>
<div class="outline-text-4" id="text-a.-离散事件模拟">
<ul class="org-ul">
<li>初步分析 <img src="https://ooo.0o0.ooo/2016/05/24/5743ed05c02fa.jpg" alt="5743ed05c02fa.jpg" /></li>
<li>进一步分析 <img src="https://ooo.0o0.ooo/2016/05/24/5743ed0fefb7a.jpg" alt="5743ed0fefb7a.jpg" /></li>
<li>过程模拟 <img src="https://ooo.0o0.ooo/2016/05/24/5743ed0f2e7c5.jpg" alt="5743ed0f2e7c5.jpg" /></li>
<li>总结 <img src="https://ooo.0o0.ooo/2016/05/24/5743ed106e6f7.jpg" alt="5743ed106e6f7.jpg" /></li>
<li><b>思考：关键是理解队列的时间性，先进先出，按时间先后顺序处理</b></li>
</ul>
</div>
</div>
</div>
</div>

<div id="org498e867" class="outline-2">
<h2 id="四迷宫问题"><a id="org498e867"></a>四、迷宫问题</h2>
<div class="outline-text-2" id="text-四迷宫问题">
</div>

<div id="orgf7b5155" class="outline-3">
<h3 id="问题分析"><a id="orgf7b5155"></a>1. 问题分析</h3>
<div class="outline-text-3" id="text-问题分析">
<ul class="org-ul">
<li>将迷宫直接映射到二维的 0/1 矩阵，用嵌套的表 [[&#x2026;],&#x2026;,[&#x2026;]]</li>
<li>每个位置分为可通与不可通，位置用序对（m，n）描述</li>
<li>每个位置有上右下左四个位置选择：(0,1),(1,0),(0,-1),(-1,0)</li>
<li>防止兜圈子，因此要记录已经走过的位置</li>
</ul>
</div>
</div>

<div id="org34517b8" class="outline-3">
<h3 id="实现方式"><a id="org34517b8"></a>2. 实现方式</h3>
<div class="outline-text-3" id="text-实现方式">
<ul class="org-ul">
<li>无路可走时退回到最开始出现分支的位置上搜索另一个分支，递归</li>
<li>无路可走时退回到最近出现分支的位置上搜索另一个分支，回溯</li>
</ul>
</div>
</div>

<div id="org58e9301" class="outline-3">
<h3 id="x3.-递归实现"><a id="org58e9301"></a>X3. 递归实现</h3>
<div class="outline-text-3" id="text-x3.-递归实现">
<p>
待补充
</p>
</div>
</div>

<div id="orgf3b02d9" class="outline-3">
<h3 id="x4.-回溯实现"><a id="orgf3b02d9"></a>X4. 回溯实现</h3>
<div class="outline-text-3" id="text-x4.-回溯实现">
<p>
待补充
</p>
</div>

<div id="orga6aa8e4" class="outline-4">
<h4 id="a.-回溯法和栈"><a id="orga6aa8e4"></a>a. 回溯法和栈</h4>
<div class="outline-text-4" id="text-a.-回溯法和栈">
<ul class="org-ul">
<li>都是从一个出发点开始，设法找到目标（搜索）</li>
<li><code>都需要使用一个栈，搜索过程的行为分为向前搜索和向后回溯</code></li>
</ul>
</div>
</div>
</div>

<div id="org59fc931" class="outline-3">
<h3 id="搜索性质"><a id="org59fc931"></a>5. 搜索性质</h3>
<div class="outline-text-3" id="text-搜索性质">
<ul class="org-ul">
<li><code>基于栈的搜索被称为“深度优先搜索”（depth-first search）</code></li>
<li><code>基于队列的搜索被称为“宽度优先搜索”（width-first search）</code></li>
</ul>
</div>
</div>
</div>
