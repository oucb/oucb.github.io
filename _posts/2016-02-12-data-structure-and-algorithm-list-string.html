---
layout     : post
title      : "《数据结构与算法:python语言描述》之 String"
categories : 数据结构与算法
tags       : 数据结构 算法 String
excerpt    : "阅读《数据结构与算法:python语言描述》课件中 “String” 部分所写笔记"
---
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#一字符串相关概念">一、字符串相关概念</a>
<ul>
<li><a href="#字符集">1. 字符集</a></li>
<li><a href="#字符串简称串">2. 字符串（简称串）</a></li>
<li><a href="#串长度">3. 串长度</a></li>
<li><a href="#一般性">4. 一般性</a></li>
<li><a href="#串判断">5. 串判断</a></li>
<li><a href="#串运算">6. 串运算</a></li>
<li><a href="#代数结构">7. 代数结构</a></li>
</ul>
</li>
<li><a href="#二字符串研究">二、字符串研究</a>
<ul>
<li><a href="#串表示的两个问题">1. 串表示的两个问题</a></li>
<li><a href="#串替换">2. 串替换</a></li>
</ul>
</li>
<li><a href="#三串匹配">三、串匹配</a>
<ul>
<li><a href="#算法设计的关键">1. 算法设计的关键</a></li>
<li><a href="#朴素匹配算法">2. 朴素匹配算法</a></li>
<li><a href="#kmp-算法">3. KMP 算法</a></li>
</ul>
</li>
<li><a href="#四正则表达式">四、正则表达式</a>
<ul>
<li><a href="#原始字符串">1. 原始字符串</a></li>
<li><a href="#元字符">2. 元字符</a></li>
<li><a href="#正则表达式对象">3. 正则表达式对象</a></li>
<li><a href="#正则表达式函数">4. 正则表达式函数</a></li>
<li><a href="#pattern-模式">5. pattern 模式</a></li>
<li><a href="#组group">6. 组（group）</a></li>
<li><a href="#其他匹配操作">7. 其他匹配操作</a></li>
<li><a href="#匹配对象match-对象操作">8. 匹配对象（match 对象操作）</a></li>
<li><a href="#正则表达式对象-1">9. 正则表达式对象</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="org75f93be" class="outline-2">
<h2 id="一字符串相关概念"><a id="org75f93be"></a>一、字符串相关概念</h2>
<div class="outline-text-2" id="text-一字符串相关概念">
</div>

<div id="org7508ff0" class="outline-3">
<h3 id="字符集"><a id="org7508ff0"></a>1. 字符集</h3>
<div class="outline-text-3" id="text-字符集">
<ul class="org-ul">
<li><code>字符</code> 是一个抽象概念，字符集是有穷的一组字符构成的集合</li>
<li>标准字符集</li>
</ul>
</div>
</div>

<div id="org94d8ff3" class="outline-3">
<h3 id="字符串简称串"><a id="org94d8ff3"></a>2. 字符串（简称串）</h3>
<div class="outline-text-3" id="text-字符串简称串">
<p>
特殊线性表，表中元素取值选定的字符集， <code>支持一组以串为对象的操作</code>
</p>
</div>
</div>

<div id="orgfd70dc2" class="outline-3">
<h3 id="串长度"><a id="orgfd70dc2"></a>3. 串长度</h3>
<div class="outline-text-3" id="text-串长度">
<ul class="org-ul">
<li>字符个数</li>
<li>长度为 0 的串称为空串</li>
<li>任意字符集里空串的唯一性</li>
</ul>
</div>
</div>

<div id="orgd0d0fa5" class="outline-3">
<h3 id="一般性"><a id="orgd0d0fa5"></a>4. 一般性</h3>
<div class="outline-text-3" id="text-一般性">
<ul class="org-ul">
<li>每个字符的位置确定</li>
<li>用 0 开始的自然数表示位置</li>
</ul>
</div>
</div>

<div id="org7853b31" class="outline-3">
<h3 id="串判断"><a id="org7853b31"></a>5. 串判断</h3>
<div class="outline-text-3" id="text-串判断">
<ul class="org-ul">
<li>相等：长度相等，且对应位置的字符分别相等</li>
<li>小于或大于：若第一个字符不相等，那就以第一个字符的比较结果为准，若第一个相等，那就比较第二个，以此类推。两串最终比较结果字符前的各字符应都对应相等。</li>
<li>子串：存在 S 和 S' 使得 S2 = S + S1 + S', 则 S1 是 S2 的字串

<ul class="org-ul">
<li><ol class="org-ol">
<li>子串也是串</li>
</ol></li>

<li><ol class="org-ol">
<li>子串第一次出现时的第一个字符位置为子串出现的位置；</li>
</ol></li>

<li><ol class="org-ol">
<li>子串可能多处出现，注意重叠情况不算</li>
</ol></li>

<li><ol class="org-ol">
<li>空串是任何字符串的子串，任何字符串是本身的子串</li>
</ol></li>
</ul></li>

<li>特殊子串：前缀是串开头的一段字符构成的子串，后缀是串最后的一段字符构成的子串</li>
</ul>
</div>
</div>

<div id="org75b4d8a" class="outline-3">
<h3 id="串运算"><a id="org75b4d8a"></a>6. 串运算</h3>
<div class="outline-text-3" id="text-串运算">
<ul class="org-ul">
<li>拼接：S = S1 + S2。python 里拼接用 <code>+</code> 表示</li>
<li>幂：串 s 的 n 次幂是连续 n 个 s 拼接而成的串：s＊n</li>
<li>替换</li>
</ul>
</div>
</div>

<div id="org74d42b1" class="outline-3">
<h3 id="代数结构"><a id="org74d42b1"></a>7. 代数结构</h3>
<div class="outline-text-3" id="text-代数结构">
<ul class="org-ul">
<li>空串是拼接操作的"单位元"（幺元） 有结合律，无交换律</li>
<li>串集合加上拼接操作，构成一个半群 典型的半交换半群</li>
<li>有单位元，因此是一个幺半群</li>
</ul>
</div>
</div>
</div>

<div id="orgae3e33b" class="outline-2">
<h2 id="二字符串研究"><a id="orgae3e33b"></a>二、字符串研究</h2>
<div class="outline-text-2" id="text-二字符串研究">
</div>

<div id="org352c7f6" class="outline-3">
<h3 id="串表示的两个问题"><a id="org352c7f6"></a>1. 串表示的两个问题</h3>
<div class="outline-text-3" id="text-串表示的两个问题">
<ul class="org-ul">
<li>串内容存储：1. 连续存储。2. 字符独立存储，链接起来</li>
<li>串结束表示：1. 专门数据域记录串长度。2. 特殊符号表示结束</li>
</ul>
</div>
</div>

<div id="org7b6e096" class="outline-3">
<h3 id="串替换"><a id="org7b6e096"></a>2. 串替换</h3>
<div class="outline-text-3" id="text-串替换">
<ul class="org-ul">
<li>子串多次出现</li>
<li>多次出现可能重叠，只能规定一种代换顺序（如从左到右），一次代换破坏的子串不应再代入新串</li>
<li>一次子串代换后，应从代入得新串之后继续工作。即使代入新串之后形成的部分能与子串匹配，也不应在本次替换中考虑</li>
</ul>
</div>
</div>
</div>

<div id="org930ca55" class="outline-2">
<h2 id="三串匹配"><a id="org930ca55"></a>三、串匹配</h2>
<div class="outline-text-2" id="text-三串匹配">
</div>

<div id="orgee58a4d" class="outline-3">
<h3 id="算法设计的关键"><a id="orgee58a4d"></a>1. 算法设计的关键</h3>
<div class="outline-text-3" id="text-算法设计的关键">
<ul class="org-ul">
<li>怎样比较字符</li>
<li>发现不匹配后下一步怎么做</li>
</ul>
</div>
</div>

<div id="orgb2d11f1" class="outline-3">
<h3 id="朴素匹配算法"><a id="orgb2d11f1"></a>2. 朴素匹配算法</h3>
<div class="outline-text-3" id="text-朴素匹配算法">
<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">nmatching</span><span style="color: #2aa198;">(</span>t, p<span style="color: #2aa198;">)</span>:
    <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = <span style="color: #6c71c4;">0</span>, <span style="color: #6c71c4;">0</span>
    <span style="color: #268bd2;">m</span>, <span style="color: #268bd2;">n</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>
    <span style="color: #859900; font-weight: bold;">while</span> i &lt; m <span style="color: #859900; font-weight: bold;">and</span> j &lt; n:
        <span style="color: #859900; font-weight: bold;">if</span> t<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> == p<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>:
            <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = i+<span style="color: #6c71c4;">1</span>, j+<span style="color: #6c71c4;">1</span>
        <span style="color: #859900; font-weight: bold;">else</span>:
            <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = i-j+<span style="color: #6c71c4;">1</span>, <span style="color: #6c71c4;">0</span>
            <span style="color: #586e75;"># </span><span style="color: #586e75;">i=i-j+1, having matched i characters, but not matching string p. need to set the position after the first matched character for the next matching</span>
    <span style="color: #859900; font-weight: bold;">if</span> j == n:
        <span style="color: #859900; font-weight: bold;">return</span> i-j
    <span style="color: #859900; font-weight: bold;">return</span> -<span style="color: #6c71c4;">1</span>
</pre>
</div>

<ul class="org-ul">
<li>从左至右</li>
<li>发现不匹配时，考虑目标串的下一位置</li>
</ul>

<blockquote>
<p>

</p>

<ul class="org-ul">
<li>可能出现回溯：遇字符不相等时，目标串每次与模式串第一个字符作比较处的位置右移一个字符，并再次从
p0（重置 j=0 后）开始比较</li>
<li>最坏的情况是每趟比较都在最后出现不等，最多比较 m-n+1 趟，总共比较
n/（m-n+1），所有算法复杂度为 n/m</li>
</ul>
</blockquote>
</div>
</div>

<div id="org404e138" class="outline-3">
<h3 id="kmp-算法"><a id="org404e138"></a>3. KMP 算法</h3>
<div class="outline-text-3" id="text-kmp-算法">
<blockquote>
<p>

</p>

<ul class="org-ul">
<li>核心思想：分析模式串，当在 tj
处不匹配时，充分利用模式串中已匹配字符的长度 i
来确定跳转到模式串中的 pk（ <code>其中 0≤k&lt;i</code> )来与 tj 继续比较。</li>
<li>例如模式串为
<code>abcac</code> ，若比较到模式串最后一个字符不匹配，这时目标串位置为 tj
的话，则 tj 继续与模式串中第二个 <code>b</code>
字符进行比较。因为模式串中第一个字符为 <code>a</code>,而匹配的时候已确认 tj
前一个为 <code>a</code></li>
</ul>
</blockquote>

<p>
解析：
</p>

<blockquote>
<p>

</p>

<ul class="org-ul">
<li>假设模式串匹配到 p[i] 时不匹配，实际上只是分析模式串中前缀子串
p0&#x2026;pi-1 中前缀子串 po&#x2026;px-1 与后缀子串 pi-x&#x2026;pi-1 的相等性及
p[x] 与 p[i] 是否相等。假定模式串为字符串
<code>s</code>'abacabad'<code>，则可看其出前缀子串 =aba</code> 、 <code>abacab</code> 、 <code>abacaba</code>
中的前后缀子串 <code>a</code> ， <code>ab</code> ， <code>abc</code> 的重复性，对应的 p[i] 分别为
p[3]、p[6]、p[7]，相应的 p[x] 分别为
p[1]、p[2]、p[3]。当模式串匹配到 p[3] 即字符 <code>c</code> 不等时，与 p[1]
不等，因此可作跳转到 p[1] 继续比较；当匹配到 p[6] 即字符 <code>a</code>
时，由于与 p[2] 相等，不能跳转。</li>
<li>假设模式串匹配到 <code>p[i]</code> 位置时不匹配，即判断 <code>p[:y]</code> 与
<code>p[i-y:i](0&lt;y&lt;i)</code> 是否匹配，选择最长的匹配，然后判断后 <code>p[y]</code> 与
<code>p[i]</code> 是否相等，以 <code>ababac</code> 为例做分析</li>
</ul>
</blockquote>

<p>
实现分析：
</p>

<blockquote>
<p>
假设 pnext[i] 为位置i的跳转位置，其中 <code>0&lt;=pnext[i]&lt;i</code>
。匹配失败时，可能发现用 pi 之前的所有字符与 tj
比较都没有价值，下一步应该从头开始用 P0 与 tj+1 比较，这种特殊情况就在
pnext[i] 里记录 -1，显然对于任何模式都有： <code>pnext[0] = -1</code>
</p>
</blockquote>

<p>
代码如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">kmpmatch</span><span style="color: #2aa198;">(</span>t, p, pnext<span style="color: #2aa198;">)</span>:
<span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = <span style="color: #6c71c4;">0</span>, <span style="color: #6c71c4;">0</span>
<span style="color: #268bd2;">m</span>, <span style="color: #268bd2;">n</span> = <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>t<span style="color: #2aa198;">)</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>
<span style="color: #859900; font-weight: bold;">while</span> i &lt; m <span style="color: #859900; font-weight: bold;">and</span> j &lt; n:
    <span style="color: #859900; font-weight: bold;">if</span> i == -<span style="color: #6c71c4;">1</span> <span style="color: #859900; font-weight: bold;">or</span> t<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> == p<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>:
        <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">j</span> = i+<span style="color: #6c71c4;">1</span>, j+<span style="color: #6c71c4;">1</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #268bd2;">j</span> = pnext<span style="color: #2aa198;">[</span>j<span style="color: #2aa198;">]</span>
<span style="color: #859900; font-weight: bold;">if</span> j ==n:
    <span style="color: #859900; font-weight: bold;">return</span> i-j
<span style="color: #859900; font-weight: bold;">return</span> -<span style="color: #6c71c4;">1</span>
</pre>
</div>
</div>

<div id="org2e17302" class="outline-4">
<h4 id="a.-kmp-算法-pnext-表分析"><a id="org2e17302"></a>a. KMP 算法 pnext 表分析</h4>
<div class="outline-text-4" id="text-a.-kmp-算法-pnext-表分析">
<ul class="org-ul">
<li>当模式串匹配到 pi 不相等时，则计算 p0&#x2026;pi-1
的最长相等的前后缀子串的长度，假设长度为 k，则
pnext[i]=k，即将模式串右移 i-k 个字符用 pk 去继续与 tj 比较</li>
<li>等价于对每个 i 求 p0&#x2026;pi-1 的最长相等前后缀子串的长度</li>
</ul>
</div>
</div>

<div id="orgb62cdf0" class="outline-4">
<h4 id="b.-pnext-递推分析"><a id="orgb62cdf0"></a>b. pnext 递推分析</h4>
<div class="outline-text-4" id="text-b.-pnext-递推分析">
<ul class="org-ul">
<li>假设 pnext[i]=k，则 p0&#x2026;pi-1 的前缀子串 p0&#x2026;pk-1 和后缀子串
pi-k&#x2026;pi-1 相同，若 pk与pi 相同，则 p0&#x2026;pi 的前缀子串 p0&#x2026;pk
和后缀子串 pi-k&#x2026;pi 相同，即 pnext[i+1]=k+1。</li>
<li>若 pk与pi 不相等，则试着在 p0&#x2026;pi-1 中更短的前后缀相同子串中检查新的
pk 是否与 pi 相等，若相等，则 pnext[i+1]=k+1</li>
</ul>

<blockquote>
<p>
通过分析最长前后缀相同子串 p0&#x2026;pk-1 和 pi-k&#x2026;pi-1 可知，p0&#x2026;pi-1
中更短的前后缀相同子串必是 p0&#x2026;pk-1 的最长前后缀相同子串，因此
k=pnext[k],p[k] 中的 k 代表 p0&#x2026;pi-1 的最长相等前后缀子串长度，即每次
p[k] 与 p[i] 不相等就去最长前缀子串 p0&#x2026;pk-1
找最长的前后缀相同子串长度 k（即 p[k] 的 pnext 值 pnext[k]），若新的
p[k] 值与 p[i] 还是不相等，则以此类推循环查找，直到 pnext[k]=-1
表示到了 p0，此时退出循环。若循环中找到使得 p[k]=p[i] 的 k
值则退出循环。最后 pnext[i+1]=k+1
</p>
</blockquote>

<ul class="org-ul">
<li>假设 pnext[0]=x，p[0] 前是空串，因此不作跳转，而 p[1] 一定会跳转到
p[0] 即 pnext[1]=0，由上述 pnext[i+1]=k+1 分析可知，定义 x=-1
能保证循环的一致性，所以定义模式串所有位置 p[i] 的 pnext 默认值为
-1，然后从 i=0 往后递推</li>
<li><p>
程序实现如下：
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">genPnext</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>:
<span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">k</span>, <span style="color: #268bd2;">m</span> = <span style="color: #6c71c4;">0</span>, -<span style="color: #6c71c4;">1</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">pnext</span> = <span style="color: #2aa198;">[</span>-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span> * m
<span style="color: #859900; font-weight: bold;">while</span> i &lt; m-<span style="color: #6c71c4;">1</span>:
    <span style="color: #859900; font-weight: bold;">while</span> k &gt;= <span style="color: #6c71c4;">0</span> <span style="color: #859900; font-weight: bold;">and</span> p<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span> <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> p<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>:
        <span style="color: #268bd2;">k</span> = pnext<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span>
    <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">k</span> = i+<span style="color: #6c71c4;">1</span>, k+<span style="color: #6c71c4;">1</span>
    <span style="color: #268bd2;">pnext</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = k
<span style="color: #859900; font-weight: bold;">return</span> pnext
</pre>
</div></li>

<li><p>
程序改进，当确认 pnext[i] 的值为 k 时，若 p[k] 与 p[i] 相同，则 p[k]
与 tj 也不相同，所以继续查找 pnext[k]
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">genPnext</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>:
<span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">k</span>, <span style="color: #268bd2;">m</span> = <span style="color: #6c71c4;">0</span>, -<span style="color: #6c71c4;">1</span>, <span style="color: #839496; font-weight: bold;">len</span><span style="color: #2aa198;">(</span>p<span style="color: #2aa198;">)</span>
<span style="color: #268bd2;">pnext</span> = <span style="color: #2aa198;">[</span>-<span style="color: #6c71c4;">1</span><span style="color: #2aa198;">]</span> * m
<span style="color: #859900; font-weight: bold;">while</span> i &lt; m-<span style="color: #6c71c4;">1</span>:
    <span style="color: #859900; font-weight: bold;">while</span> k &gt;= <span style="color: #6c71c4;">0</span> <span style="color: #859900; font-weight: bold;">and</span> p<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span> <span style="color: #859900; font-weight: bold;">is</span> <span style="color: #859900; font-weight: bold;">not</span> p<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>:
        <span style="color: #268bd2;">k</span> = pnext<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span>
    <span style="color: #268bd2;">i</span>, <span style="color: #268bd2;">k</span> = i+<span style="color: #6c71c4;">1</span>, k+<span style="color: #6c71c4;">1</span>
    <span style="color: #859900; font-weight: bold;">if</span> p<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span> == p<span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span>:
        <span style="color: #268bd2;">pnext</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = pnext<span style="color: #2aa198;">[</span>k<span style="color: #2aa198;">]</span>
    <span style="color: #859900; font-weight: bold;">else</span>:
        <span style="color: #268bd2;">pnext</span><span style="color: #2aa198;">[</span>i<span style="color: #2aa198;">]</span> = k
<span style="color: #859900; font-weight: bold;">return</span> pnext
</pre>
</div></li>
</ul>
</div>
</div>
</div>
</div>

<div id="org8a6576e" class="outline-2">
<h2 id="四正则表达式"><a id="org8a6576e"></a>四、正则表达式</h2>
<div class="outline-text-2" id="text-四正则表达式">
</div>

<div id="org1456749" class="outline-3">
<h3 id="原始字符串"><a id="org1456749"></a>1. 原始字符串</h3>
<div class="outline-text-3" id="text-原始字符串">
<ul class="org-ul">
<li>在普通字符串前加r或R前缀，如 <code>r"abadef", R"c:\text\x"</code></li>
<li>原始字符串中的  不作为转义符</li>
<li>为了使一些字符串写法简单</li>
</ul>
</div>
</div>

<div id="orgb53aec1" class="outline-3">
<h3 id="元字符"><a id="orgb53aec1"></a>2. 元字符</h3>
<div class="outline-text-3" id="text-元字符">
<p>
<code>. ^ $ * + ? \ | { } [ ] ( )</code>
</p>
</div>
</div>

<div id="org574d668" class="outline-3">
<h3 id="正则表达式对象"><a id="org574d668"></a>3. 正则表达式对象</h3>
<div class="outline-text-3" id="text-正则表达式对象">
<ul class="org-ul">
<li>通过 <code>re.compile(pattern, flag = 0)</code> 从 pattern
生成正则表达式对象，例如 r1 =
re.compile("abc")，将生成的正则表达式对象赋给变量 r1</li>
<li>避免在重复使用中重复生成</li>
</ul>
</div>
</div>

<div id="org8efe099" class="outline-3">
<h3 id="正则表达式函数"><a id="org8efe099"></a>4. 正则表达式函数</h3>
<div class="outline-text-3" id="text-正则表达式函数">
<ul class="org-ul">
<li><code>re.search(pattern, string, flag=0)</code> 在 string 里检索与 pattern
匹配的子串，找到就返回一个 match 类型的对象，没有就返回 None，match
记录成功匹配的相关信息，可把它作为一个真值用于逻辑判断</li>
<li><code>re.match(pattern, string, flag=0)</code> 检查 string 中是否有与 pattern
匹配的前缀，成功返回 match 对象，否则返回 None</li>
<li><p>
<code>re.split(pattern, string, maxsplit=0, flags=0)</code> 以 pattern
作为分割串将 string 分段，maxsplit 指明分割数，0 表示做完整个
string。返回分割得到的字符串表。
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; re.split<span style="color: #2aa198;">(</span><span style="color: #2aa198;">' '</span>, <span style="color: #2aa198;">"abc abb are not the same"</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'abc'</span>, <span style="color: #2aa198;">'abb'</span>, <span style="color: #2aa198;">'are'</span>, <span style="color: #2aa198;">'not'</span>, <span style="color: #2aa198;">'the'</span>, <span style="color: #2aa198;">'same'</span><span style="color: #2aa198;">]</span>
&gt;&gt;&gt; re.split<span style="color: #2aa198;">(</span><span style="color: #2aa198;">' '</span>, <span style="color: #2aa198;">"1 2  3  4 "</span><span style="color: #2aa198;">)</span>
&gt;&gt;&gt; <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'1'</span>, <span style="color: #2aa198;">'2'</span>, <span style="color: #2aa198;">''</span>, <span style="color: #2aa198;">'3'</span>, <span style="color: #2aa198;">''</span>, <span style="color: #2aa198;">'4'</span>, <span style="color: #2aa198;">''</span><span style="color: #2aa198;">]</span>
</pre>
</div></li>

<li><code>re.findall(pattern, string, flags=0)</code> 返回一个表，按顺序给出 string
里与 pattern 匹配的各个子串</li>
</ul>
</div>
</div>

<div id="orge2509f2" class="outline-3">
<h3 id="pattern-模式"><a id="orge2509f2"></a>5. pattern 模式</h3>
<div class="outline-text-3" id="text-pattern-模式">
<ul class="org-ul">
<li><b>字符组表达式 [&#x2026;]，匹配括号中的任一个字符</b> <code>[abc]</code> ：匹配 a 或 b 或
c 区间形式 <code>[0-9]</code> ：顺序列出的缩写，匹配所有十进制数字字符
<code>[0-9a-zA-Z]</code> ：匹配所有字母（英文）和数字</li>
<li><b>求补表达式 <code>[^...]</code> ，匹配未在括号里列出的字符</b>
<code>[^0-9]</code> ：匹配所有非十进制数字的字符
<code>[^ \t\v\n\f\r]</code> ：匹配所有非空白字符（非空格 / 制表符 / 换行符）</li>
<li><b>圆点字符 <code>.</code> 匹配任意一个字符</b> <code>a..b</code> ：匹配所有以 a 开头 b
结束的四字符串</li>
<li><p>
<b>重复运算符 <code>*</code> ， <code>a*</code> 表示匹配 a 的 0 次或任意多次出现</b>
</p>

<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; re.split<span style="color: #2aa198;">[</span><span style="color: #2aa198;">'[ ,]*'</span>, <span style="color: #2aa198;">'1 2, 3   4, , 5'</span><span style="color: #2aa198;">]</span>
&gt;&gt;&gt; <span style="color: #2aa198;">[</span><span style="color: #2aa198;">'1'</span>, <span style="color: #2aa198;">'2'</span>, <span style="color: #2aa198;">'3'</span>, <span style="color: #2aa198;">'4'</span>, <span style="color: #2aa198;">'5'</span><span style="color: #2aa198;">]</span>
</pre>
</div></li>

<li><b>重复运算符 <code>+</code> ，表示 1 次或多次重复。与 <code>*</code> 略微不同</b> 例如 <code>'\d+'</code>
等价于 <code>'\d\d*'</code></li>
<li><b>可选（片段）用 <code>?</code> 运算符表示</b> <code>?</code> 表示 0 次或 1
次重复，例如描述整数的一种简单模式 <code>'-?\d+'</code></li>
<li><b>确定次数的重复用 <code>{n}</code> 表示， <code>a{n}</code> 与 a 的 n 次重复串匹配</b>
例如描述北京的常规号码： <code>'(010-)?[2-9][0-9]{7}'</code></li>
<li><b>上述的圆括号是描述 <code>?</code> 的作用范围</b> <code>*,?,{n}</code>
有作用范围问题（优先级），它们作用于最小表达式， <code>'010-?'=表示 =-</code>
可选， <code>'(010-)?'</code> 表示整个段可选</li>
<li><b>重复范围用 <code>{m,n}</code> 表示， <code>a{m,n}</code> 表示匹配 m 到 n 个 a 的串</b>
<code>a{3，7}</code> 与 3 到 7 个 a 构成的串匹配 其中 m 和 n 均可以省略， <code>a{,n}</code>
表示 <code>a{0,n}</code> ， <code>a{m,}</code> 表示 <code>a{m,inifinity}</code> ， <code>a{n}</code> 等价于
<code>a{n,n}</code> ， <code>a?</code> 等价于 <code>a{0,1}</code> ， <code>a*</code> 等价于 <code>a{0,inifinity)</code> ， <code>a+</code>
等价于 <code>a{1,inifinity}</code></li>
<li><b>选择运算符 <code>|</code> 描述两种或多种情况之一的匹配，如果 a 或 b
与一个串匹配，那么 a|b 就与之匹配</b> <code>a|b|c</code> 可以匹配 a 或 b 或 c，[abc]
可看作其简写</li>
<li><b>行首匹配：以 \^ 符号开头的模式，只能与一行的前缀子串匹配</b>
<code>re.search('^for', 'books for children')</code> 得到 None</li>
<li><b>行尾匹配：以 $ 符号结尾的模式，只能与一行的后缀子串匹配</b>
<code>re.search('fisth$', 'cats like to eat fishes')</code> 得到 None</li>
<li><b>注意，"一行的"前缀 / 后缀包括整个被匹配串的前缀和后缀</b>
如果串里有换行符，还包括换行符钱的子串（一行的后缀）和其后的子串（前缀）
<code>串首匹配</code> ：\A 开头的模式只与被匹配串的前缀匹配
<code>串尾匹配</code> ：\Z 结束的模式只与被匹配串的后缀匹配</li>
<li><b>贪婪匹配与非贪婪匹配</b> <code>* + ? {m,n}</code>
都采取贪婪匹配策略，与被匹配串中最长的合适子串匹配 <code>*? +? ?? {m,n}?</code>
个运算符后加一个问号，采用分贪婪匹配（最小匹配）</li>
<li>如果要在字符组里包括 <code>^</code> ，就不能放在第一个位置，或者写成 <code>\^</code> ，同理
<code>- ]</code> ，也要写成 <code>\-</code> 和 \]</li>
<li><b>为了方便，re 用转义形式定义了一些常用字符组</b> <code>\d</code> ：等价于 [0-9]
<code>\D</code> ：等价于 [\^0-9] <code>\s</code> ：等价于 [ \t\v\n\f\r] <code>\S</code> ：等价于 [\^
\t\v\n\f\t] <code>\w</code> ：等价于 [0-9a-zA-Z] <code>\W</code> ：等价于 [\^0-9a-zA-Z]</li>
</ul>
</div>
</div>

<div id="org7cee3fb" class="outline-3">
<h3 id="组group"><a id="org7cee3fb"></a>6. 组（group）</h3>
<div class="outline-text-3" id="text-组group">
<ul class="org-ul">
<li>圆括号阔起的模式段（&#x2026;）也是模式，同时还确定了一个被匹配的‘组'（字符段），该组可在后面使用，要求匹配同样字符串</li>
<li>可用 <code>\n</code> 形式在模式里‘引用'组，组从 1 开始编号 例如 <code>r'(.{2} \1'</code>
可匹配 'ok ok' 或 'no no'，不匹配 'no oh'， <code>\1</code> 要写成 <code>\\1</code>
或使用原始字符串形式</li>
</ul>
</div>
</div>

<div id="org59fdade" class="outline-3">
<h3 id="其他匹配操作"><a id="org59fdade"></a>7. 其他匹配操作</h3>
<div class="outline-text-3" id="text-其他匹配操作">
<ul class="org-ul">
<li><code>re.fullmatch(pattern, string, flags=0)</code> 若整个 string 与 pattern
匹配成功将返回相应的 match 对象，否则返回 None</li>
<li><code>re.finditer(pattern, string, flags=0)</code> 与 findall
类似，但返回的不是表而是一个迭代器，使用该迭代器可顺序取得表示各非重叠匹配的
match 对象</li>
<li><code>re.sub(pattern, repl, string, count=0, flags=0)</code> 做替换，把 string
里顺序与 pattern 匹配的各非重叠子串用 repl 代换。repl
是串则直接代换，同时 repl 还可以是以 match
对象为参数的函数，这时用函数的返回值代换被匹配子串 例如把串 text 里的
\t 都代换为 4 个空格， <code>re.sub('\t', '    ', text)</code></li>
</ul>
</div>
</div>

<div id="org4dd1469" class="outline-3">
<h3 id="匹配对象match-对象操作"><a id="org4dd1469"></a>8. 匹配对象（match 对象操作）</h3>
<div class="outline-text-3" id="text-匹配对象match-对象操作">
<ul class="org-ul">
<li>假设 mat 表示通过匹配得到的一个 match 对象，mat 可用于逻辑判断</li>
<li>取得被匹配的子串： <code>mat.group()</code></li>
<li>在目标串中的匹配位置： <code>mat.start()</code>
得到成功匹配在目标串里的实际匹配位置， <code>mat.end()</code>
表示被匹配子串的结束位置 假设 text 是目标串，则
<code>mat.group() =</code> text[mat.start():mat.end()]=</li>
<li>目标串里被匹配的区间： <code>mat.span()</code>
得到匹配开始和结束位置形成的二元组， <code>mat.span() =</code> mat.start(), mat.end()=</li>
</ul>
</div>
</div>

<div id="org206671f" class="outline-3">
<h3 id="正则表达式对象-1"><a id="org206671f"></a>9. 正则表达式对象</h3>
<div class="outline-text-3" id="text-正则表达式对象-1">
<p>
正则表达式对象支持一组方法，与直接使用 re.xxx
形式相比较，这组方法功能更多，使用更灵活。假设 regex
代表一个正则表达式对象
</p>

<ul class="org-ul">
<li><code>regex.search(string[,pos[,endpos]])</code> 在给定的串 string
里检索，可指定开始和结束位置。默认从头到尾，pos 指定开始位置，endpos
指定结束位置</li>
<li><code>regex.match(string[,pos[,endpos]])</code> 检查给定 string 串是否有与 regex
匹配的前缀</li>
<li>`regex.fullmatch(string[,pos[,endpos]]) 检查 string
指定范围构成的子串是否与 regex 匹配，默认范围是整个串</li>
<li>以下两个与 re. 同名且功能类似，但可指定匹配范围
<code>regex.findall(string[,pos[,endpos]])</code>
<code>regex.finditer(string[,pos[,endpos]])</code></li>
<li>下面两个与 re. 同名且功能相同 切分： <code>regex.split(string, maxsplit=0)</code>
替换： <code>regex.sub(repl, string, count=0)</code></li>
<li><code>regex.pattern</code> 取得生成 regex 所用的模式字符串</li>
</ul>
</div>

<div id="org1dcd1c7" class="outline-4">
<h4 id="思考"><a id="org1dcd1c7"></a>思考</h4>
<div class="outline-text-4" id="text-思考">
<p>
<b>推导 pnext
最关键的是循环在前一字符的最长前后缀字串中查找当前字符的最长前后缀字串</b>
</p>
</div>
</div>
</div>
</div>
